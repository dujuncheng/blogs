数据结构的学科是问题驱动发展而来的。现实生活中面临问题, 存在已知和未知的数据，我们需要从已知数据中，建立模型，推断出未知数据。当我们存入数据的时候，采用不同的数据结构会影响算法的效率。
![](http://p8cyzbt5x.bkt.clouddn.com/UC20180523_193006.png)
简单来说：数据结构是研究数据之间的关系、如何组织数据结构，为高效的算法提供基础。

>逻辑结构：是在脑海里想出来的，是可以画出在纸上面的
>存储结构：可以被存在计算机里面的

数据结构的本质
1. 画逻辑结构
2. 定义存储结构
3. 写代码完成操作

### 逻辑结构分四类
- 无关系：集合
- 1对1关系: 线性结构
- 1对多关系： 树
- 多对多关系： 图
### 存储结构
- 顺序存储结构
- 链式存储结构
- 索引存储结构
- 散列存储结构

对于一个问题，一定有唯一的逻辑结构，但可选不同的存储结构，从而得到了不同的效率

## 本文整体框架
![](http://p8cyzbt5x.bkt.clouddn.com/UC20180523_202334.png)

## 本文学习方法
第一遍学习数据结构的记忆点:概念+思想
第二遍是实现算法



# 绪论

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180529_092643.png)

## 内存
数据所存储的载体：内存
内存的特点
1. 线性的一维的
2. 对内存的操作分为读和写
3. 内存分为不同的存储单元，每个存储单元存放一个字节
4. 每个存储单元都有一个地址

> 内存中有两类值，一种是内存中的内存值，一种是存储单元的地址

## 算法
### 算法特点5个
1. 可行性
2. 确定性
3. 有穷性
4. 0个或者0以上的输入
4. 1个或者1个以上的输出

### 算法设计的要求
1. 正确性
2. 可读性
3. 健壮性
4. 效率和低存储量的需求

### 算法的评价标准
#### 时间复杂度
1. 不同的机器上运行时间不同，因此是个估计值
2. 影响因素： 规模，输入
3. O(n)——语句重复执行的次数
   - O(1) 常量阶 和n无关
   - O(log n) log n阶
   - O(n) n阶
   - O(n log n)
   - O(n<sup>2</sup>)
   - O(n<sup>3</sup>)
   - O(2<sup>n</sup>)
   


#### 空间复杂度
1. 所占用的总空间：算法本身运行占用的空间 + 辅助空间 + 输入数据所占用的空间


## 抽象数据类型(ADT)
数据类型在c中分为4类, 比如说int在空间中占用2个字节，可以进行 `+` `-` `*` `/` `%`的操作
int是已经定义好的数据类型，抽象数据类型是我们自定义的
### ADT主要内容
1. 存储结构 + 操作
2. 描述规则
不同大学采用的教材不同，ADT的描述规则不同
```c
ADT 类型名
{
  # 数据
  # 操作
};
```
 

# 线性结构
## 特点
1. 首节点只有后继，没有前驱
2. 尾节点只有前驱，没有后继
3. 其余节点关系为1对1, 一个前驱，一个后继
4. 逻辑结构上相邻，存储结构上也相邻
## 类型
1. 线性表(国内大部分教材的重点, 很多教材讲顺序结构就是讲线性表)
   线性表分2种存储结构： 
   - 顺序存储(顺序表)
   - 链式存储（链表）——单链表、双链表、循环链表
2. 栈
3. 队列
4. 串

### 线性表两种存储结构下的不同操作
学习中，遇到问题首先判断是否是线性结构，然后选择线性表的不同存储方式——顺序存储或链式存储
不同存储方式对应不同的操作
-----------------------------
#### 顺序表（线性表的顺序存储结构）
##### 定义
在内存中是连续的，可以定义为数组
##### 操作
可以理解为对数据的操作, 主要包括建表——查询——增——删——改——输出

--------------------------------

#### 链表（线性表的链式存储结构）
特点：
1. 内存空间不必连续
2. 节点中有内容和指针，是不同类型。而c语言中结构体可以把不同的类型封装在一起，从而构造一种新的类型

定义存储结构
数据域和指针域是不同的类型
```c
struct node 
{
    int data;   // 数据域
    struct node *next; // 指向自身的指针域
}
```
操作
1. 创建链表
链表的内存空间是动态申请的，通过malloc来申请，返回指向节点的指针

    ![](http://p8cyzbt5x.bkt.clouddn.com/UC20180529_193334.png)
    
    ```c
    // 生成指针
    struct node *p1, *p2, *p3
    // 建立节点p1
    p1 = new node
    p1 -> data = a1
    // 建立节点p2
    p2 = new node 
    p2 -> data = a2
    // p1的next指针指向p2
    p1 -> next = p2
    ```

2. 链表查询
查询是需要创建完整的链表
遍历并不是通过 p++, 而是通过`p=p->next`指针的移动
    ```c
    p0 = p
    while (p0 -> data !== a3)
    {
      p0 = p0 -> next
    }
    ```
    
       
3. 链表的插入
先找到插入位置前一个节点，
    ```c
    p0 = p
    // 找到前一个
    // p -> data p指针所指向的那个节点的data
    // p -> next -> p指针后面的那个节点的data
    while(p->next->data != a3)
    { 
        p = p->next
    }
    ```
然先链后断
![](http://p8cyzbt5x.bkt.clouddn.com/UC20180529_202410.png)

    ```c
    s -> next = p -> next
    p -> next = s
    ```

4. 链表删除
 假设删除的元素是a3, a3前一个节点指针是p
     ```c
     while(p->next->data != a3)
     {
       p = p -> next
     }
     p -> next = p -> next -> next
     ```
 只需要一步跨过去，不需要切断a3节点的next
 
 5. 链表的逆序
 

##### 单向链表




## 学习方法












#栈
## 基本概念
### 定义
### 特点
### 术语
### 计算

## 逻辑结构

## 存储结构 


