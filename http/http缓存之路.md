在网上看多了太多讲缓存的博客，但是感觉总是站在前端的角度来看，总有一种隔靴搔痒的感觉，感觉理解的不彻底。于是就看《HTTP权威指南》，现在把笔记整理如下：

私有缓存和公有缓存：
私有缓存
浏览器内建的

公有代理缓存
在缓存服务器上，接受多个用户的访问，减少冗余流量；


代理缓存的层次结构
靠近客户端的地方用小型廉价缓存，更高层级中，使用更大，功能更强的缓存
 
 
处理流程：
一条http get 报文的基本缓存处理过程图：

下面是对这张图的解释：
1. 判断是否缓存？
如何判断？

本地副本可以在计算机里面，内存里面，甚至附近的计算机里面，缓存可以用快速算法来确定有没有缓存。
如果没有缓存，则直接向服务器发起请求

如果有缓存，则进行下一步

 
2.  判断是否新鲜？
新鲜（Freshness）

一旦资源被存到了缓存中，理论上可以永久的保存在硬盘上。但是缓存的空间是有限的，所以缓存会定期的被清理出去，这种过程被称为 cache eviction. 
另一方面，服务端的资源会更新，而http单向通讯特点，决定了服务端的资源更新时，无法及时的通知客户端和缓存。所以，服务器只好在一开始就告诉客户端某资源的过期时间。在过期时间之前，该资源是新鲜的，在过期时间之后，该资源就变质了(stale)。
注意，变质的资源并不会从缓存中直接删除。当客户端发起一个请求，请求的资源是不新鲜的（抄超过了cacheControl或者 expires的值），则cache会向 origin server发起一条请求（该请求被称为再验证），该请求会带有 if - none  - match 请求头去询问origin server 该资源是否还新鲜。如果还新鲜，则服务器返回304，不带返回体。


如何判断是否新鲜？

缓存过期的两个标准 Cache_control ( http1.1,相对时间 ) 、expires( http1.0, 绝对时间 ),  这两个值是通过服务器响应对文档添加的过期时间

cache-control

1.   no-cache
不管过了过长时间，要先去origin server进行再验证
2.  no-store
直接禁止浏览器以及所有中间缓存存储任何版本的返回响应，例如，包含个人隐私数据或银行业务数据的响应。每次用户请求该资产时，都会向服务器发送请求，并下载完整的响应。
3. public

4. private

5. max-age
设置一个相对时间
6. must-revalidate
同 no -cache

7. 不加任何东西，缓存自己决定
试探性过期，使用LM_Factor 的算法，浏览器自行决定，如果是比较老的，就比较稳定，缓存时间长，如果比较新，则缓存时间短




cache_control 和 expires 同时出现，以cache_control为准
cache_control 和 expires 都没有出现，找到 last-modified ，用 date 头减去 last-modified, 再除以10就是过期秒数。

判断完新鲜结果有两个：

1. 如果没有过期，缓存创建响应，看起来和服务器的响应一样。
2. 如果过期了，则进行下一步再验证

Revved resources (修改资源)

我们越使用缓存，页面的打开速度就越快。理论上来讲，资源的过期时间越久越好。但是有个问题就是我们的资源有可能会频繁的更新。web 工程师发明了一种方法，Steve Souders 将其称之为 revving，文件的名称由文件名和版本号组成。为了获取新的资源，链接将会被更新，比如说css的链接，或者js的链接。
这种方法有一个额外的好处，我同时修改了js和相应的css文件，这两个新版本的文件必须要配合在一起使用，而用户本地因为cache-control 不一样，有可能会同时使用新版本的js和旧版本的css, 这就会导致报错。
因为能够定义每个资源的缓存策略，所以您可以定义“缓存层次结构”，这样不但可以控制每个响应的缓存时间，还可以控制访问者看到新版本的速度。

HTML 被标记为“no-cache”，这意味着浏览器在每次请求时都始终会重新验证文档，并在内容变化时获取最新版本。此外，在 HTML 标记内，您在 CSS 和 JavaScript 的url中带上版本号，比如说hash值，如果这些文件的内容发生变化，网页的 HTML 也会随之改变，标记为 cache-control:  no-cache的html资源会下载 HTML 响应的新副本。
CSS缓存，并且过期时间设置为1年，您可以放心地使用 1 年的“远期过期”，因为您在文件名中带上了版本号，CSS 更新时，html里面的css链接也会随之变化，更新之后的css就使用了新的css
JavaScript 同样设置为 1 年后到期，但标记为 private，这或许是因为它包含的某些用户私人数据是 CDN 不应缓存的。
图像缓存时不包含版本或唯一指纹，并设置为 1 天后到期。

 
3.  进行再验证

如何判断？

缓存向 origin 服务器发送一个get请求。如果通过验证，则返回304，如果没有通过验证，则返回新的文档; 两件事一起办；
再验证常用的请求头：if - modified - since 和 if - none - match
if - modified - since

缓存发给origin服务器的再验证get请求中, 会带上if - modified -since请求头，该条再验证请求称为 IMS请求。

1. 如果此时服务器的资源更新，if - modified - since 条件为真，返回给缓存 新文档+新过期日期（ cache_control or expires ）
2. 如果没有更新，if - modified -since 条件为假，则返回给 浏览器 304+ 新的过期时间（ cache_control or expires ）

if - modified - since  请求头的值为该资源上一次origin 服务器添加的响应头 last - modified的值。 
if - modified- since : < cached  last - modified date >
如果服务器注意到 请求头 if - modified - since 和服务器文档最后修改的日期相符，则返回304




if - none - match

if - modified - since 有时候不好用的原因：
1.  周期新的被重写，但是内容没有发生改变
2.   如果文件被修改了注释，但是无关紧要。

通过给文件加上 etag 版本号，如果发布了重大的更新，则更新etag, 
如果请求过来的 if - none - match : ' V2.6', 服务器的etag也是v2.6, 则通过，返回304
如果请求过来的 if - none -match : ' v2.6 ' , 服务器的etag 却是 v2.7， 则返回新文档和新的etag
那么究竟用哪个

如果请求是 if - modified - since , 就用last-modified 来匹配，如果请求是 if - none -match ，就用etag 来匹配，如果两个都有，那么只有两个都通过的时候才会返回304
 
 
 
最近在准备面试，也遇到了另外一种说法：
浏览器缓存分两种：强缓存和协商缓存。
强缓存

cache-control
expires
协商缓存

if-modified - since : last - modified
if - none -match ：etag


 

 
 
前端如何控制缓存


1
2
<metahttp-equiv='Expires'content="Mon,20Jul201623:00:00GMT">
<metahttp-equiv="Cache-Control"content="max-age=7200"
    >单位是毫秒，同时设定听Cache-Control的
 
 

三种刷新
浏览器中写地址，回车
F5
Ctrl+F5

浏览器url回车

浏览器发现缓存中有这个文件了，好了，就不发送任何请求了，直接去缓存中获取展现。（最快）
按下了F5刷新

F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since：Wed, 10 Aug 2013 15:32:18 GMT
然后服务器发现：诶，这个文件我在这个时间后还没修改过，不需要给你任何信息了，返回304就行了。于是浏览器获取到304后就去缓存中欢欢喜喜获取资源了。
按下了Ctrl+F5

这个可是要命了，告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作...
还有说一下，那个ETag实际上很少人使用，因为它的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用etag了。
 
 
 