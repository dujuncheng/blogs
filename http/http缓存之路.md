在网上看多了太多讲缓存的博客，但是感觉总是站在前端的角度来看，总有一种隔靴搔痒的感觉，感觉理解的不彻底。于是就看《HTTP权威指南》，现在把笔记整理如下：


# 缓存
很多开发者习惯把cookie、webStorage以及IndexedDB存储的数据也称之为缓存，理由是都是保存在客户端的数据，没有什么区别。其实这是不严谨的，cookie的存在更多的是为了让服务端区别用户，webStorage和IndexedDB则更多用在保存具体的数据和在客户端存储大量结构化数据(文件/blobs)上面。
实际上所谓的缓存只有一种——它是请求资源的副本。

# 缓存的分类
缓存在宏观上可以分成两类：
私有缓存和共享缓存。

共享缓存就是那些能被各级代理缓存的缓存(咋觉得有点绕)。

私有缓存就是用户专享的，各级代理不能缓存的缓存。

微观上可以分下面三类：
1. 浏览器缓存
我相信只要你经常使用某个浏览器(Chrome,Firefox,IE等)，肯定知道这些浏览器在设置里面都是有个清除缓存功能，这个功能存在的作用就是删除存储在你本地磁盘上资源副本，也就是清除缓存。
缓存存在的意义就是当用户点击back按钮或是再次去访问某个页面的时候能够更快的响应。尤其是在多页应用的网站中，如果你在多个页面使用了一张相同的图片，那么缓存这张图片就变得特别的有用。😏
2. 代理服务器缓存
代理服务器缓存原理和浏览器端类似，但规模要大得多，因为是为成千上万的用户提供缓存机制，大公司和大型的ISP提供商通常会将它们设立在防火墙上或是作为一个独立的设备来运营。(下文如果没有特殊说明,所有提到的缓存服务器都是指代理服务器。)
由于缓存服务器不是客户端或是源服务器的一部分，它们存在于网络中，请求路由必须经过它们才会生效，所以实际上你可以去手动设置浏览器的代理，或是通过一个中间服务器来进行转发，这样用户自然就察觉不到代理服务器的存在了。🤥
代理服务器缓存就是一个共享缓存，不只为一个用户服务，经常为大量用户使用，因此在减少相应时间和带宽使用方面很有效：因为同一个缓存可能会被重用多次。
3. 网关缓存
也被称为代理缓存或反向代理缓存，网关也是一个中间服务器，网关缓存一般是网站管理员自己部署，从让网站拥有更好的性能。🙂
CDNS(网络内容分发商)分布网关缓存到整个（或部分）互联网上，并出售缓存服务给需要的网站，比如国内的七牛云、又拍云都有这种服务。
4. 数据库缓存
数据库缓存是指当我们的应用极其复杂，表自然也很繁杂，我们必须进行频繁的进行数据库查询，这样可能导致数据库不堪重负，一个好的办法就是将查询后的数据放到内存中，下一次查询直接从内存中取就好了。关于数据库缓存本篇不会展开。🙃


代理缓存的层次结构
靠近客户端的地方用小型廉价缓存，更高层级中，使用更大，功能更强的缓存
 
 
# 缓存流程
一条http get 报文的基本缓存处理过程图：




## 1. 判断是否存在缓存

本地副本可以在计算机里面，内存里面，甚至附近的计算机里面，缓存可以用快速算法来确定有没有缓存。
如果没有缓存，则直接向服务器发起请求
如果有缓存，则进行新鲜度检测

 
## 2. 新鲜度检测 (又称为强缓存阶段)
### 新鲜（Freshness）
一旦资源被存到了缓存中，理论上可以永久的保存在硬盘上。
但是缓存的空间是有限的，所以缓存会定期的被清理出去，这种过程被称为`cache eviction`。 
另一方面，服务端的资源会更新，而http单向通讯特点，决定了服务端的资源更新时，无法及时的通知客户端和缓存。
所以，服务器只好在一开始就告诉客户端某资源的过期时间。
在过期时间之前，该资源是新鲜的，在过期时间之后，该资源就变质了(stale)。

当客户端发起一个请求，请求的资源超过了cacheControl或者 expires的值，
则cache会向`origin server`发起一条请求（该请求被称为再验证，我们会在下文中讨论）。


### 如何判断是否新鲜？

新鲜度的两个标准 `Cache_control` ( http1.1,相对时间 ) 、`expires`( http1.0, 绝对时间 )

#### cache-control 常用的值

1. no-cache
不管过了过长时间，要先去origin server进行再验证
2. no-store
直接禁止浏览器以及所有中间缓存存储任何版本的返回响应，例如，包含个人隐私数据或银行业务数据的响应。每次用户请求该资产时，都会向服务器发送请求，并下载完整的响应。
3. public
任意一方都能缓存该资源(客户端、代理服务器等)
4. private
只能特定用户缓存该资源
5. max-age
设置一个相对时间, 缓存时长，单位是秒
6. must-revalidate
同 `no-cache`
7. 不加任何东西，缓存自己决定
试探性过期，使用LM_Factor 的算法，浏览器自行决定，如果是比较老的，就比较稳定，缓存时间长，如果比较新，则缓存时间短

> 请注意no-cache指令很多人误以为是不缓存，这是不准确的，no-cache的意思是可以缓存，但每次用应该去想服务器验证缓存是否可用。no-store才是不缓存内容。


cache_control 和 expires 同时出现，以cache_control为准
cache_control 和 expires 都没有出现，找到 last-modified ，用 date 头减去 last-modified, 再除以10就是过期秒数。

判断完新鲜结果有两个：

1. 如果没有过期，缓存创建响应，看起来和服务器的响应一样。
2. 如果过期了，则进行下一步再验证

Revved resources (修改资源)

我们越使用缓存，页面的打开速度就越快。理论上来讲，资源的过期时间越久越好。但是有个问题就是我们的资源有可能会频繁的更新。web 工程师发明了一种方法，Steve Souders 将其称之为 revving，文件的名称由文件名和版本号组成。为了获取新的资源，链接将会被更新，比如说css的链接，或者js的链接。
这种方法有一个额外的好处，我同时修改了js和相应的css文件，这两个新版本的文件必须要配合在一起使用，而用户本地因为cache-control 不一样，有可能会同时使用新版本的js和旧版本的css, 这就会导致报错。
因为能够定义每个资源的缓存策略，所以您可以定义“缓存层次结构”，这样不但可以控制每个响应的缓存时间，还可以控制访问者看到新版本的速度。

HTML 被标记为“no-cache”，这意味着浏览器在每次请求时都始终会重新验证文档，并在内容变化时获取最新版本。此外，在 HTML 标记内，您在 CSS 和 JavaScript 的url中带上版本号，比如说hash值，如果这些文件的内容发生变化，网页的 HTML 也会随之改变，标记为 cache-control:  no-cache的html资源会下载 HTML 响应的新副本。
CSS缓存，并且过期时间设置为1年，您可以放心地使用 1 年的“远期过期”，因为您在文件名中带上了版本号，CSS 更新时，html里面的css链接也会随之变化，更新之后的css就使用了新的css
JavaScript 同样设置为 1 年后到期，但标记为 private，这或许是因为它包含的某些用户私人数据是 CDN 不应缓存的。
图像缓存时不包含版本或唯一指纹，并设置为 1 天后到期。




## 关于缓存是从磁盘中获取还是从内存中获取，
一个较为可信的结论：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很高会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。

 
## 3. 再验证 (弱缓存)

缓存向 origin 服务器发送一个get请求。如果通过验证，则返回304，如果没有通过验证，则返回新的文档; 两件事一起办；

### 再验证常用的请求头

#### if-modified-since

缓存发给origin服务器的再验证请求中, 会带上`if-modified-since`请求头，该条再验证请求称为`IMS`请求。

在浏览器第一次请求某一个URL时，服务器端的返回状态码会是200，响应的实体内容是客户端请求的资源，同时有一个`Last-Modified`的响应头标记此文件在服务器端最后被修改的时间。

当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器会把第一次Last-Modified的值存储在If-Modified-Since里面发送给服务端来验证资源有没有修改。like this:

```
if-modified-since: Fri , 12 May 2006 18:53:33 GMT
```


1. 如果此时服务器的资源更新，`if-modified-since`条件为真，返回给缓存新文档, 和新过期日期（ cache_control or expires ）
2. 如果没有更新，`if-modified-since` 条件为假，则返回给浏览器304，和新的过期时间（ cache_control or expires ）







if - none - match

if - modified - since 有时候不好用的原因：
1.  周期新的被重写，但是内容没有发生改变
2.   如果文件被修改了注释，但是无关紧要。

通过给文件加上 etag 版本号，如果发布了重大的更新，则更新etag, 
如果请求过来的 if - none - match : ' V2.6', 服务器的etag也是v2.6, 则通过，返回304
如果请求过来的 if - none -match : ' v2.6 ' , 服务器的etag 却是 v2.7， 则返回新文档和新的etag
那么究竟用哪个

如果请求是 if - modified - since , 就用last-modified 来匹配，如果请求是 if - none -match ，就用etag 来匹配，如果两个都有，那么只有两个都通过的时候才会返回304
 
 
 
最近在准备面试，也遇到了另外一种说法：
浏览器缓存分两种：强缓存和协商缓存。
强缓存

cache-control
expires
协商缓存

if-modified - since : last - modified
if - none -match ：etag


 

 
 
前端如何控制缓存


1
2
<metahttp-equiv='Expires'content="Mon,20Jul201623:00:00GMT">
<metahttp-equiv="Cache-Control"content="max-age=7200"
    >单位是毫秒，同时设定听Cache-Control的
 
 

三种刷新
浏览器中写地址，回车
F5
Ctrl+F5

浏览器url回车

浏览器发现缓存中有这个文件了，好了，就不发送任何请求了，直接去缓存中获取展现。（最快）
按下了F5刷新

F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since：Wed, 10 Aug 2013 15:32:18 GMT
然后服务器发现：诶，这个文件我在这个时间后还没修改过，不需要给你任何信息了，返回304就行了。于是浏览器获取到304后就去缓存中欢欢喜喜获取资源了。
按下了Ctrl+F5

这个可是要命了，告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作...
还有说一下，那个ETag实际上很少人使用，因为它的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用etag了。
 
 
 