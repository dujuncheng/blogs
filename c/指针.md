# 指针变量的定义

c语言中有两种变量：

1. 值变量（普通变量） 存内容值
2. 地址变量（指针变量） 存地址值

## 定义格式

指针变量的定义格式为 **类型名 *指针变量名**

```c
 // 定义语句
 int a,b,*p1,*p2;
 float x,y,*p3,*p4;
 char s, *p5,*p6;
```

注意点：

1. 不管是值变量，还是指针变量，都必须在声明的时候指定类型名；

2. `*p` 的变量名是`p`。***** 符号并不是变量名的一部分，因为变量名不能包含特殊符号，；

3. 指针变量只能用来存地址，不能将整型值赋值给指针变量；

   （内容变量存内容，指针变量存地址）

   ```c
   int a,b,*p;
   a = 1000;
   b = 2000;
   p = 3000;   // 报错
   ```



## 两个运算符

1. `&` 取地址运算符，取出**普通变量**的地址；

- 优先级二级。
- 运算顺序是从右向左。
- 右侧只能放内容变量。



2. `*` 指针运算符，取出指针变量所指向的内存空间中的值。

- 优先级二级
- 从右向左
- 右侧只能放指针变量。

需要注意的是`*` 在c语言中有三种身份：

1. 乘运算符，比如说`7*8`；
2. 指针声明的标志
3. 指针运算符



`&` 和 `*` 为互逆的操作，`&` 为取出内容变量的地址， `*` 为取出地址变量对应的内容值。

```c
int a,b=20,c=30,d=40, *p;
p=&d;
a=*p;  // 相当于 a=d;
```



```c
// 此段代码正确
int a = 10;
// 此时的星号是声明
int *P = &a; 

// 此段代码不正确
int a = 10;
int *p;
*p = &a;  // 左侧为内容值，右侧为地址值，故报错
```

注意点：

1. 应该在声明的同时初始化。

   这是以为如果声明时没有初始化，指针是指向内存中的随机区域，很危险

2. 下面的等价表

   ```c
   int a = 20, *p = &a;
   
   // 下面的值均是等价的
   1. &a <=> p
   2. *p <=> a
   3. &(*p) <=> &a <=> p
   4. *(&a) <=> *p <=> a
   5. (*p)++ <=> a++
      (*p)-- <=> a--
      ++(*p) <=> ++a
      --(*p) <=> --a
   ```

3. 所有指针变量在内存中占的字节数相同。 sizeof()

   ```c
   int *p1;
   float *p2;
   double *p3;
   ```

   指针变量存的是房子的地址，至于房子多大，不会影响到房子地址的大小。



例子1

```c
// 参数是地址变量声明
void fun(int *x, int *y){
  printf("%d %d", *x, *y);
  *x = 3;
  *y = 4;
}


main() {
  int x = 1, y = 2;
  fun(&x, &y);
  printf("%d %d",x,y)
}
```



## 数组 指针变量

### 一维数组

```c
int s[10],a,b;
int b[3][6];
int *p;

// 下面的三行代码都是合法的
p = &a;
p = &s[2];
p = &b[2][4];
```

1. 数组名代表数组的**首地址**

   ```c
   int s[10];
   s <=> &s[0];
   ```

   当一个指针被赋值为一个数组名时，等价于该指针指向该数组的第一个元素的地址。

   ```c
   int s[10], *p;
   p = s <=> p = &s[0];
   ```

2. 指针变量加1，意味着后移动一位，指针变量减1，意味着前移动一位。

   ```c
   float a[10], *p;
   p = &a[4];
   ```

   上面的代码中，p-3指向a[1]的地址。

3. 地址三等价原则，元素四个等价原则

   ```c 
   int a[N], *p = a;
   
   // 地址三等价
   p+i <=> a+i <=> &a[i]
   
   // 元素四等价
   *(p+i) <=> *(a+i) <=> a[i] <=> p[i]
   
   // p[] []是下标运算符，表示向下移动i个位置
   ```

   根据上面的原则，我们可以推导出下面的等价表：

   ```c 
    *(p+i) <=> *(a+i) <=> a[i] <=> p[i]
   
    p++ <=> ++p <=> p+=1 <=> p=p+1
     
    p-- <=> --p <=> p-=1 <=> p=p-1
      
    *p++ <=> *(p++)  // 取出旧的地址中的元素，然后p加1
    *++p <=> *(++p)  // p加1，取出新地址中的元素
    (*p)++ <=> ++(*p) <=> ++*p  // 取出p中的元素，然后加1
    (*p)-- <=> --(*p) <=> --*p  // 取出p中的元素，然后减1  
   ```

4. 两个指针变量可以比较大小，可以做减法

   ```c
   char s[10];
   char *p1 = s+3, *p2 = &s[7];
   
   p2 > p1
   p2 - p1 = 4
   ```



### 二维数组

二维数组有两个规律：

1. “ 地址三等价，元素四等价 ”
2. 因为是二维数组，所以两个`[]`，或者两次`* `访问到元素；一次`[]`或者一次`* `访问到地址

```c
 // 地址三等价
 // 以为是二维数组，所以两次[]，或者两次* 
 &a[i][j] <=> a[i] + j <=> *(a + i)+j
 
 // 元素四等价
 a[i][j] <=> *(*(a+i) + j) <=> *(a[i]+j) <=> *(a+i)[j]
```

列指针指向元素，行指针指向一行。

#### 列指针变量定义

```
类型 *p
```

#### 行指针变量定义：

```c
 类型 (*p) [m];
 // m 是数组的列数
```

```c
int a[5][7];
int (*p)[7];

int b[10][80];
int (*r)[80];
```



二维数组的题需要画图，分两种情况：行指针，列指针

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180723_231739.png)



行指针解题口诀：

1. 画二维表
2. 等价代换
3. 画斜杠



## 字符串指针变量

c 语言中没有字符串变量来存字符串常量，因此我们的解决方法

1. 字符串数组
2. 指针



字符串占用连续的存储空间，就是第一个字符的地址

>  字符串 “abc” 用 ‘a’ 字符的地址来表示 



```c
char str[] = "abc"
char *p = "abc"
  
char *p = {"abc"} // 不合法，字符串指针只能是""s
chat str[] = {"abc"} //合法，因为str是字符型数组
char *p; *p = "abc"  // 不合法，“abc” 是地址值，*p 需要接收内容值
```



```c
main() {
  char s[20] = "abcd";
  char *p = "1234";
  
  print("%s\n",s+2)  // %s的作用是，从这里一直到\0输出
                     // s是 &s[0], 因此 s+2是c的地址,
  print("%s\n",p+5)   // p是指向字符串第一个字符的地址
    
  print("%s\n", strcat(s+3,p+4))  // strcat函数比较奇怪，是第二个连在第一个后面， p+4的位置到第一个\0的一串，连到s+3的位置开始找，第一个\0的后面，返回s+3的位置
// 因此strcat()第一个位置不影响链接，但是会影响输出
    
}
```











