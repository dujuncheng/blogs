数据结构的学科是问题驱动发展而来的。现实生活中面临问题, 存在已知和未知的数据，我们需要从已知数据中，建立模型，推断出未知数据。当我们存入数据的时候，采用不同的数据结构会影响算法的效率。
![](http://p8cyzbt5x.bkt.clouddn.com/UC20180523_193006.png)
简单来说：数据结构是研究数据之间的关系、如何组织数据结构，为高效的算法提供基础。

>逻辑结构：是在脑海里想出来的，是可以画出在纸上面的
>存储结构：可以被存在计算机里面的

数据结构的本质
1. 画逻辑结构
2. 定义存储结构
3. 写代码完成操作

### 逻辑结构分四类
- 无关系：集合
- 1对1关系: 线性结构
- 1对多关系： 树
- 多对多关系： 图
### 存储结构
- 顺序存储结构
- 链式存储结构
- 索引存储结构
- 散列存储结构

对于一个问题，一定有唯一的逻辑结构，但可选不同的存储结构，从而得到了不同的效率

## 本文整体框架
![](http://p8cyzbt5x.bkt.clouddn.com/UC20180523_202334.png)

## 本文学习方法
第一遍学习数据结构的记忆点:概念+思想
第二遍是实现算法



# 绪论

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180529_092643.png)

## 内存
数据所存储的载体：内存
内存的特点
1. 线性的一维的
2. 对内存的操作分为读和写
3. 内存分为不同的存储单元，每个存储单元存放一个字节
4. 每个存储单元都有一个地址

> 内存中有两类值，一种是内存中的内存值，一种是存储单元的地址

## 算法
### 算法特点5个
1. 可行性
2. 确定性
3. 有穷性
4. 0个或者0以上的输入
4. 1个或者1个以上的输出

### 算法设计的要求
1. 正确性
2. 可读性
3. 健壮性
4. 效率和低存储量的需求

### 算法的评价标准
#### 时间复杂度
1. 不同的机器上运行时间不同，因此是个估计值
2. 影响因素： 规模，输入
3. O(n)——语句重复执行的次数
   - O(1) 常量阶 和n无关
   - O(log n) log n阶
   - O(n) n阶
   - O(n log n)
   - O(n<sup>2</sup>)
   - O(n<sup>3</sup>)
   - O(2<sup>n</sup>)
   


#### 空间复杂度
1. 所占用的总空间：算法本身运行占用的空间 + 辅助空间 + 输入数据所占用的空间


## 抽象数据类型(ADT)
数据类型在c中分为4类, 比如说int在空间中占用2个字节，可以进行 `+` `-` `*` `/` `%`的操作
int是已经定义好的数据类型，抽象数据类型是我们自定义的
### ADT主要内容
1. 存储结构 + 操作
2. 描述规则
不同大学采用的教材不同，ADT的描述规则不同
```c
ADT 类型名
{
  # 数据
  # 操作
};
```
 

# 线性结构
## 特点
1. 首节点只有后继，没有前驱
2. 尾节点只有前驱，没有后继
3. 其余节点关系为1对1, 一个前驱，一个后继
4. 逻辑结构上相邻，存储结构上也相邻
## 类型
1. 线性表(国内大部分教材的重点, 很多教材讲顺序结构就是讲线性表)
   线性表分2种存储结构： 
   - 顺序存储(顺序表)
   - 链式存储（链表）——单链表、双链表、循环链表
2. 栈
3. 队列
4. 串

### 线性表两种存储结构下的不同操作
学习中，遇到问题首先判断是否是线性结构，然后选择线性表的不同存储方式——顺序存储或链式存储
不同存储方式对应不同的操作
-----------------------------
#### 顺序表（线性表的顺序存储结构）
##### 定义
在内存中是连续的，可以定义为数组
##### 操作
可以理解为对数据的操作, 主要包括建表——查询——增——删——改——输出

--------------------------------

#### 链表（线性表的链式存储结构）
特点：
1. 内存空间不必连续
2. 节点中有内容和指针，是不同类型。而c语言中结构体可以把不同的类型封装在一起，从而构造一种新的类型

定义存储结构
数据域和指针域是不同的类型
```c
struct node 
{
    int data;   // 数据域
    struct node *next; // 指向自身的指针域
}
```
操作
1. 创建链表
链表的内存空间是动态申请的，通过malloc来申请，返回指向节点的指针

    ![](http://p8cyzbt5x.bkt.clouddn.com/UC20180529_193334.png)
    
    ```c
    // 生成指针
    struct node *p1, *p2, *p3
    // 建立节点p1
    p1 = new node
    p1 -> data = a1
    // 建立节点p2
    p2 = new node 
    p2 -> data = a2
    // p1的next指针指向p2
    p1 -> next = p2
    ```

2. 链表查询
查询是需要创建完整的链表
遍历并不是通过 p++, 而是通过`p=p->next`指针的移动
    ```c
    p0 = p
    while (p0 -> data !== a3)
    {
      p0 = p0 -> next
    }
    ```
    
       
3. 链表的插入
先找到插入位置前一个节点，
    ```c
    p0 = p
    // 找到前一个
    // p -> data p指针所指向的那个节点的data
    // p -> next -> p指针后面的那个节点的data
    while(p->next->data != a3)
    { 
        p = p->next
    }
    ```
然先链后断
![](http://p8cyzbt5x.bkt.clouddn.com/UC20180529_202410.png)

    ```c
    s -> next = p -> next
    p -> next = s
    ```

4. 链表删除
 假设删除的元素是a3, a3前一个节点指针是p
     ```c
     while(p->next->data != a3)
     {
       p = p -> next
     }
     p -> next = p -> next -> next
     ```
 只需要一步跨过去，不需要切断a3节点的next
 
 5. 链表的逆序
 
 6. 链表的合并
    ```c
     f(x) = ax<sup>3</sup> + bx + c
     f(x) = ax<sup>4</sup> - bx + e
    ```
    上面两个多项式合并，如下图所示
    
    ![](http://p8cyzbt5x.bkt.clouddn.com/UC20180530_093925.png)
    
 7. 链表的输出
 遍历输出每一个节点
 ```c
  // 如果判断条件是 p -> next != null, 则最后一个节点无法输出
  while( p!= null)
  {
    p = p -> next
  }

 ```
    
    

##### 单向链表

##### 循环链表
最后一个节点的指针域指向第一个节点

##### 双向链表




----------------------------------

#栈 
## 基本概念
一端受限的数据结构
### 定义
### 特点
LIFO
### 术语
1. 栈底
2. 栈顶
### 计算
1. 进出栈的顺序

> a b c d 为入栈顺序，下面哪一个是不可能的出栈顺序
> 1. dcba
> 2. cbda
> 3. bdac
> 4. adcb


2. 栈的容量
> 入栈顺序是abcd入栈，出栈顺序是abcd, 求栈的容量
> 1个存储单元

> 入栈的顺序是abcd, 出栈的顺序是bdca出，求栈的容量
> 3

3. 栈中元素出入时指针顺序
在初始状态时，top指针有两种情况，
一种是开始时指向0 ，先进来一个元素，然后top ++ (top指向刚进来元素的上面)
一种是开始时指向-1, 先top++，然后再进来元素 (top指向刚进来的元素)

4. 已知top位置，求实际元素个数？



## 存储结构 
### 顺序存储
```c
typedef struct {
  SElemType *base;
  SElemtType *top;
  // 栈的大小
  int stacksize;
} SqStack;
SqStack s;
```

1. 如果top指向最上面元素的上一个，则个数为 `top - bottom` 个
2. 如果top指向最上面的元素，则个数为 `top - bottom + 1` 个


几点说明：
1. 栈空条件： s.top = s.base 此时不能出栈
2. 栈满条件: s.top - s.base >= s.stacksize
3. 进栈操作： *s.top++ = e 或者 *s.top=e; s.top++
4. 退栈操作： e = -- *s.top 或者 s.top--; e = *s.top
5. 栈满了再进站会“上溢”
6. 栈空了再出站会“下溢”

### 链式存储


## 栈的应用
1. 数制的转换
2. 表达式的求值


-----------------------------------------

# 队列
## 定义
运算受限，限定在表的一端删除，另一端进行插入的线性表
允许删除的叫队头，允许插入的叫队尾
特性是：先进先出


## 存储结构
### 链式存储结构
实质是带头结点的线性链表

两个指针：
1. 队头指针Q.front 指向头结点
2. 队尾指针Q.front 指向尾节点

初始态：队空条件
头指针和尾指针均指向头结点
Q.front = Q.rear


队满条件:
链式存储，空间动态申请

```c
typedef struct QNode {
    QElemType data;
    // 指向自身的指针
    struct QNode *next;
} QNode, *QueuePtr;

typedef struct {
  QueuePtr font;
  QueuePrt rear;
} LinkQueue;

LinkQueue Q;
Q.front // 指向头节点
Q.rear  // 指向链尾节点
```

头节点的调整——出队



### 基本操作
1. 初始化
2. 销毁队列
3. 入队
4. 出队
5. 判断队空
6. 取头元素


### 顺序存储
 用一组**地址连续**的存储单元，依次存放从队头到队尾的元素
 
 
 设两个指针
 1. Q.front 指向队列头元素
 2. Q.rear 指向队列尾元素的下一个位置
 
 
 初始状态: 空队列
 Q.front = Q.rear = 0
 
 队列的真满和假满
 
 ![](http://p8cyzbt5x.bkt.clouddn.com/UC20180611_083348.png)
 上图所示
 有空房子为假满
 
 为了解决假满现象—— “循环队列”，循环队列是顺序队列的一种解决方案，考研中说道顺序队列，就是循环队列
 
 
 ### 循环队列

 循环队列是顺序队列的改造
 ![](http://p8cyzbt5x.bkt.clouddn.com/UC20180611_084157.png)

 MAX = 5
 Q.rear = ( Q.rear + 1 ) % MAX
 
 
 队满的标志
 Q.front == Q.rear
 
 
 #### 6个基本操作
 1. 队空
    Q.front == Q.rear
 2. 队满
    Q.front == ( Q.rear + 1 ) % MAX 
 3. 入队
    Q.rear = ( Q.rear + 1 ) % MAX
 4. 出队
    Q.front =  ( Q.front + 1 ) % MAX   
 5. 循环队列最多元素个数
    MAX空间数
    最大元素个数 =  MAX - 1 (牺牲了一个存放rear)
 6. 循环队列实际元素
    已知，Q.front Q.rear，求多少个元素
    方法1，画图
    方法2，按公式计算
    