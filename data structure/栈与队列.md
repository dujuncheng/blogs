#栈 
## 基本概念
一端受限的数据结构
### 定义
### 特点
LIFO
### 术语
1. 栈底
2. 栈顶
### 计算
1. 进出栈的顺序

> a b c d 为入栈顺序，下面哪一个是不可能的出栈顺序
> 1. dcba
> 2. cbda
> 3. bdac
> 4. adcb


2. 栈的容量
> 入栈顺序是abcd入栈，出栈顺序是abcd, 求栈的容量
> 1个存储单元

> 入栈的顺序是abcd, 出栈的顺序是bdca出，求栈的容量
> 3

3. 栈中元素出入时指针顺序
在初始状态时，top指针有两种情况，
一种是开始时指向0 ，先进来一个元素，然后top ++ (top指向刚进来元素的上面)
一种是开始时指向-1, 先top++，然后再进来元素 (top指向刚进来的元素)

4. 已知top位置，求实际元素个数？



## 存储结构 
### 顺序存储
```c
typedef struct {
  SElemType *base;
  SElemtType *top;
  // 栈的大小
  int stacksize;
} SqStack;
SqStack s;
```

1. 如果top指向最上面元素的上一个，则个数为 `top - bottom` 个
2. 如果top指向最上面的元素，则个数为 `top - bottom + 1` 个


几点说明：
1. 栈空条件： s.top = s.base 此时不能出栈
2. 栈满条件: s.top - s.base >= s.stacksize
3. 进栈操作： *s.top++ = e 或者 *s.top=e; s.top++
4. 退栈操作： e = -- *s.top 或者 s.top--; e = *s.top
5. 栈满了再进站会“上溢”
6. 栈空了再出站会“下溢”

### 链式存储


## 栈的应用
1. 数制的转换
2. 表达式的求值


-----------------------------------------

# 队列
## 定义
运算受限，限定在表的一端删除，另一端进行插入的线性表
允许删除的叫队头，允许插入的叫队尾
特性是：先进先出


## 存储结构
### 链式存储结构
实质是带头结点的线性链表

两个指针：
1. 队头指针Q.front 指向头结点
2. 队尾指针Q.front 指向尾节点

初始态：队空条件
头指针和尾指针均指向头结点
Q.front = Q.rear


队满条件:
链式存储，空间动态申请

```c
typedef struct QNode {
    QElemType data;
    // 指向自身的指针
    struct QNode *next;
} QNode, *QueuePtr;

typedef struct {
  QueuePtr font;
  QueuePrt rear;
} LinkQueue;

LinkQueue Q;
Q.front // 指向头节点
Q.rear  // 指向链尾节点
```

头节点的调整——出队



### 基本操作
1. 初始化
2. 销毁队列
3. 入队
4. 出队
5. 判断队空
6. 取头元素


### 顺序存储
 用一组**地址连续**的存储单元，依次存放从队头到队尾的元素
 
 
 设两个指针
 1. Q.front 指向队列头元素
 2. Q.rear 指向队列尾元素的下一个位置
 
 
 初始状态: 空队列
 Q.front = Q.rear = 0
 
 队列的真满和假满
 
 ![](http://p8cyzbt5x.bkt.clouddn.com/UC20180611_083348.png)
 上图所示
 有空房子为假满
 
 为了解决假满现象—— “循环队列”，循环队列是顺序队列的一种解决方案，考研中说道顺序队列，就是循环队列
 
 
 ### 循环队列

 循环队列是顺序队列的改造
 ![](http://p8cyzbt5x.bkt.clouddn.com/UC20180611_084157.png)

 MAX = 5
 Q.rear = ( Q.rear + 1 ) % MAX
 
 
 队满的标志
 Q.front == Q.rear
 
 
 #### 6个基本操作
 1. 队空
    Q.front == Q.rear
 2. 队满
    Q.front == ( Q.front + 1 ) % MAX 
 3. 入队
    Q.rear = ( Q.rear + 1 ) % MAX
 4. 出队
    Q.front =  ( Q.front + 1 ) % MAX   
 5. 循环队列最多元素个数
    MAX空间数
    最大元素个数 =  MAX - 1 (牺牲了一个存放rear)
 6. 循环队列实际元素
    已知，Q.front Q.rear，求多少个元素
    方法1，画图
    方法2，按公式计算
    ( Q.rear + MAX - Q.front ) % MAX