我们的页面需要交互流畅，而交互流畅的判断标准是 ` 60fps `。

这是因为目前大多数设备的屏幕刷新率为 **60 次/秒**，也就是 ` 60fps ` , 如果刷新率降低，也就是说出现了掉帧, 对于用户来说，就是出现了卡顿的现象。

这就要求，每一帧的渲染时间仅为**16毫秒** (1 秒/ 60 = 16.66 毫秒)。

但实际上，浏览器有其他工作要做，因此这一帧所有工作需要在 10毫秒内完成。如果工作没有完成，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。

优化页面的性能，需要对浏览器的渲染过程有深入的了解，针对浏览器的每一步环节进行优化。

# 浏览器渲染流程

浏览器一开始会从网络层获取请求文档的内容，请求过来的数据是 Bytes，然后浏览器将其编译成HTML的代码。

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180705_005723.png)

但是html代码浏览器是看不懂的，所以需要进行解析。

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180619_195129.png)

渲染引擎解析 HTML 文档，将各个dom标签逐个转化成“content tree”上的 DOM 节点。同时也会解析内部和外部的css, 解析为`CSSOM tree`, `css tree`和`dom tree`结合在一起生成了`render tree`

`render tree`是由一系列在按照顺序排列起来的方块组成的，每一个方块都包含类似于颜色、尺寸的信息。

在`render tree`构建好之后，渲染引擎就会经历一个`layout`的阶段: 计算出每一个节点应该出现在屏幕上的确切坐标。

之后的阶段被称为`paiting`阶段，渲染引擎会遍历`render tree`, 然后由用户界面后端层将每一个节点绘制出来。

渲染引擎会尽快把内容呈现在屏幕上，因此不会等待整个文档加载之后才开始构建，而是一边加载一部分，渲染引擎一边渲染一部分。

![webkit 渲染引擎的主流程](http://p8cyzbt5x.bkt.clouddn.com/UC20180619_200256.png)



下面，我们针对浏览器上面的环节，逐一的介绍一下如何去进行页面的优化。



# 第一步：解析

解析是渲染引擎中非常重要的一个环节。我们现在先不管html解析、css解析之类的。我们先大致了解一下解析到底是怎么一回事。

## 什么是解析

通俗来讲，解析文档是指将**文档转化成为有意义的结构，好让代码去使用他们**。

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180704_145218.png)

解析可以分为两大块，一块是**vocabulary**，另一块是**syntax rules**。

以上面图中为例， `1 + 2 * 3` 的代码中，**valcabulary** 包括`1`、`2`、`3`，除此之外，`+` 、`*` 等运算符也属于valcabulary。 

**syntax rules**主要是规定了valcabulary 之间是如何相互组合的，比如说，`+` 可以放在数字的左边，也可以放在数字的后面，`*` 的运算优先级要比 `+` 更高。

上面的图，右边就是解析好的树状结构，这个结构就可以“喂“给其他的程序, 然后其他的程序就可以利用这个结构，生成一些计算的结果。

解析的过程可以分成两个子过程：**lexical analysis(词法分析)**和**syntax analysis(句法分析)**。

### 解析的过程

#### **lexical analysis(词法分析)**

**lexical analysis**的过程，有的文章也称为 **tokenization**，其实就是把输入的内容分为不同的**tokens**(不知道怎么翻译，国内有博客翻译为标记)，tokens是最小的组成部分，tokens就像是人类语言中的一堆词汇。比如说，我们对一句英文进行lexical analysis——“The quick brown fox jumps”，我们可以拿到以下的token:

- “The”
- “quick”
- “brown”
- “fox”
- “jumps”

那么用来做lexical analysis的工具，被称为**`lexer`**， 它负责把输入的内容分为不同的tokens。不同的浏览器会选择不同的lexer , 比如说webkit 是使用Flex 作为lexer。

#### syntax analysis(句法分析)

**syntax analysis**是应用语言句法中的规则， 简单来说，就是判断一串tokens组成的句子是不是正确的。

如果我说：“我吃饭工作完了”， 这句话是不符合syntax analysis的，虽然里面的每一个token都是正确的，但是不符合语法规范。需要注意的是，符合语法正确 的句子不一定是符合语义正确的。比如说，“一个绿色的梦想沉沉的睡去了”，从语法的角度来讲，形容词 + 主语 + 副词 + 动词没有问题，但是语义上却是什么鬼。

负责`syntax analysis`工作的是**`parser`**，解析是一个不断往返的过程。

如下图所示，`parser`向`lexer`要一个新的`token`，`lexer`会返回一个`token`, `parser`拿到`token`之后，会尝试将这个`token`与某条语法规则进行匹配。

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180704_151126.png)

如果该`token`匹配上了语法规则，`parser`会将一个对应的节点添加到 parse tree （解析树，如果是html就是dom树，如果是css就是 cssom tree）中，然后继续问parser要下一个node。

当然，也有可能该`tokens`没有匹配上语法规则，`parser`会将`tokens`暂时保存，然后继续问`lexer`要`tokens`, 直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，`parser`就会引发一个异常。这意味着文档无效，包含语法错误。

`syntax analysis` 的输出结果是parse tree ( 这里不是dom tree, 也不是 cssom tree , 因为我们这里讨论的是普遍性一般性的解析 ) , parse tree 的结构表示了句法结构。比如说我们输入"John hit the ball"作为一句话，那么 `syntax analysis` 的结果就是：

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180704_165209.png)

一旦我们拿到了`parse tree`， 还有最后一步工作没有做，那就是：`translation`，还有一些博客将这个过程成为 compilation / transpilation / interpretation 

### **Lexicons 和 Syntaxes**

`lexicons` 和 `syntaxes` 是什么东西呢？

上面提到了`lexer` 和 `parser` 这两个解析工具，我们通常不会自己写，而是用现有的工具去生成。我们只需要提供一个语言的 `lexicon` 和 `syntaxes` ，就可以自动生成相应的 `lexer` 和 `parser` 了。

#### lexicons

lexicons 是通过正则表达式被定义的，比如说，js中的保留字，就是lexicons 的一部分。

下面就是js中的保留字的正则表达式 的一部分。

```
/^(?!(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)*$/
```

#### syntaxes

`syntaxes` 通常是被一个叫**无上下文语法**所定义，关于**无上下文语法**可以点击这个[链接](https://en.wikipedia.org/wiki/Context-free_grammar)（因为我也看不懂哈哈），反正只需要知道，无上下文语法要比常规的语法更复杂就好了。

webkit 就是用这样两种工具**：Flex**  和 **Bison**

`flex` 和`css` 的 `flex` 布局没有关系，是 `fast-lexer` 的简写，用来生成 `lexer`。 它需要一个`lexicon`，这个`lexicon` 是用一堆正则表达式来定义的 。

bison 用来生成**parsers,**  它需要一个符合**BNF范式**的syntax。 

#### BNF范式

非科班出身的前端可能不了解 BNF 范式（说的就是我 --），它是一种形式化符号来描述给定语言的语法。

它的内容大致为：

1. 在双引号中的字("word")代表着这些字符本身。
2. 而double_quote用来代表双引号。
3. 在双引号外的字（有可能有下划线）代表着语法部分。
4. 尖括号( < > )内包含的为必选项。
5. 方括号( [ ] )内包含的为可选项。
6. 大括号( { } )内包含的为可重复0至无数次的项。
7. 竖线( | )表示在其左右两边任选一项，相当于"OR"的意思。
8. ::= 是“被定义为”的意思。

下面是用BNF来定义的Java语言中的For语句的实例。

```
FOR_STATEMENT ::=
"for" "(" ( variable_declaration |
( expression ";" ) | ";" )
[ expression ] ";"
[ expression ]
")" statement
```



> BNF 的诞生还是挺有意思的一件事情， 有了BNF才有了真正意义上的计算机语言。巴科斯范式直到今天，仍然是个迷，巴科斯是如何想到的



### 小结

我们现在对解析过程有了一个大致的了解，总结成一张图就是这样：

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180704_204630.png)



接下来，我们专门讨论一下HTML的解析过程。

## 解析HTML 

html 是不规范的，我们在写html的代码时候，比如说漏了一个闭合标签，浏览器也可以正常渲染没有问题的。这是一把双刃剑，我们可以很容易的编写html, 但是却给html的解析带来不少的麻烦，更详细的信息可以点击：[链接](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#HTML_Parser)

### lexicon

Html 的 lexicon 主要包括6个部分：

- doctype
- start tag
- end tag
- comment
- character
- End-of-file

当一个html文档被lexer 处理的时候，lexer 从文档中一个字符一个字符的读出来，并且使用 finite-state machine 来判断一个完整的token是否已经被完整的收到了。

### syntax

这里就是html 解析的复杂所在了。html 标签的容错性很高，需要上下文敏感的语法。

比如说对于下面两段代码：

```html
<!DOCTYPE html>
<html lang="en-US">
  <head>
    <title>Valid HTML</title>
  </head>
  <body>
    <p>This is a paragraph. <span>This is a span.</span></p>
    <div>This is a div.</div>
  </body>
</html>
```

```html
<html lAnG = EN-US>
<p>This is a paragraph. <span>This is a span. <div>This is a div.
```

第一段是规范的html代码，第二段代码有非常多的错误，但是这两段代码在浏览器中都是大致相同的结构：

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180704_211329.png)

上面两处代码渲染出来的唯一的不同就是，正确的html会在头部有`<!DOCTYPE html>`,  这行代码会触发浏览器的标准模式。

所以你看，html 的容错性是非常高的，这样是有代价的，这增加了解析的困难，让词法解析解析更加困难。

### DOM tree

HTML 解析出来的 parse html 并不是严格意义上的DOM tree。为了在浏览器里面用， Dom tree 是对解析出来的 parse tree做了进一步的加工。

对于下面这种html的结构：

```html
<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1">
  </head>
  <body>
    <p>
      This is text in a paragraph.
      <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/Rubber_Duck_%288374802487%29.jpg/220px-Rubber_Duck_%288374802487%29.jpg">
    </p>
    <div>
      This is text in a div.
    </div>
  </body>
</html>
```

上面的html 的结构解析出来应该是：

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180704_211037.png)



说完了html的解析，我们就该说CSS的解析了。

## 解析CSS 

和html 解析相比，css 的解析就简单很多了。 

### lexicon

关于css的 `lexicon`， [the W3C’s CSS2 Level 2 spec](https://www.w3.org/TR/CSS2/syndata.html#tokenization)ification 中已经给出了。

CSS 中的 token 被列在了下面，下面的定义是采用了`Lex`风格的正则表达式。

```
IDENT	{ident}
ATKEYWORD	@{ident}
STRING	{string}
BAD_STRING	{badstring}
BAD_URI	{baduri}
BAD_COMMENT	{badcomment}
HASH	#{name}
NUMBER	{num}
PERCENTAGE	{num}%
DIMENSION	{num}{ident}
URI	url\({w}{string}{w}\)
|url\({w}([!#$%&*-\[\]-~]|{nonascii}|{escape})*{w}\)
UNICODE-RANGE	u\+[0-9a-f?]{1,6}(-[0-9a-f]{1,6})?
CDO	<!--
CDC	-->
:	:
;	;
{	\{
}	\}
(	\(
)	\)
[	\[
]	\]
S	[ \t\r\n\f]+
COMMENT	\/\*[^*]*\*+([^/*][^*]*\*+)*\/
FUNCTION	{ident}\(
INCLUDES	~=
DASHMATCH	|=
DELIM	any other character not matched by the above rules, and neither a single nor a double quote
```

花括号里面的宏被定义成如下：

```
ident	[-]?{nmstart}{nmchar}*
name	{nmchar}+
nmstart	[_a-z]|{nonascii}|{escape}
nonascii	[^\0-\237]
unicode	\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
escape	{unicode}|\\[^\n\r\f0-9a-f]
nmchar	[_a-z0-9-]|{nonascii}|{escape}
num	[0-9]+|[0-9]*\.[0-9]+
string	{string1}|{string2}
string1	\"([^\n\r\f\\"]|\\{nl}|{escape})*\"
string2	\'([^\n\r\f\\']|\\{nl}|{escape})*\'
badstring	{badstring1}|{badstring2}
badstring1	\"([^\n\r\f\\"]|\\{nl}|{escape})*\\?
badstring2	\'([^\n\r\f\\']|\\{nl}|{escape})*\\?
badcomment	{badcomment1}|{badcomment2}
badcomment1	\/\*[^*]*\*+([^/*][^*]*\*+)*
badcomment2	\/\*[^*]*(\*+[^/*][^*]*)*
baduri	{baduri1}|{baduri2}|{baduri3}
baduri1	url\({w}([!#$%&*-~]|{nonascii}|{escape})*{w}
baduri2	url\({w}{string}{w}
baduri3	url\({w}{badstring}
nl	\n|\r\n|\r|\f
w	[ \t\r\n\f]*
```

### Syntax

下面是css的 syntax 定义：

```
stylesheet  : [ CDO | CDC | S | statement ]*;
statement   : ruleset | at-rule;
at-rule     : ATKEYWORD S* any* [ block | ';' S* ];
block       : '{' S* [ any | block | ATKEYWORD S* | ';' S* ]* '}' S*;
ruleset     : selector? '{' S* declaration? [ ';' S* declaration? ]* '}' S*;
selector    : any+;
declaration : property S* ':' S* value;
property    : IDENT;
value       : [ any | block | ATKEYWORD S* ]+;
any         : [ IDENT | NUMBER | PERCENTAGE | DIMENSION | STRING
              | DELIM | URI | HASH | UNICODE-RANGE | INCLUDES
              | DASHMATCH | ':' | FUNCTION S* [any|unused]* ')'
              | '(' S* [any|unused]* ')' | '[' S* [any|unused]* ']'
              ] S*;
unused      : block | ATKEYWORD S* | ';' S* | CDO S* | CDC S*;
```



### CSSOM Tree

CSS解析得到的parse tree 经过加工之后，就得到了**CSSOM Tree**。 **CSSOM** 被称为“css 对象模型”。

CSSOM Tree 对外定义接口，可以通过js去获取和修改其中的内容。开发者可以通过`document.styleSheets`的接口获取到当前页面中所有的css样式表。

#### CSSOM

那么CSSOM 到底长什么样子呢，我们下面来看一下：

```
<!doctype html>
<html lang="en">
<head>
    <style>
        .test1 {
            color: red;
        }
    </style>
    <style>
        .test2 {
            color: green;
        }
    </style>
    <link rel="stylesheet" href="./test3.css">
</head>
<body>
    <div class="test1">TEST CSSOM1</div>
    <div class="test2">TEST CSSOM2</div>
    <div class="test3">TEST CSSOM3</div>
</body>
</html>
```

上面的代码在浏览器中打开，然后在控制台里面输入`document.styleSheets`，就可以打印出来CSSOM，如下图所示：

![image-20180710202919478](/var/folders/np/g8g6bsy50p9c6qz76pytrb1m0000gn/T/abnerworks.Typora/image-20180710202919478.png)

可以看到，CSSOM是一个对象，其中有三个属性，均是	CSSStylelSheet 对象。CSSStylelSheet 对象用于表示每个样式表。由于我们在document里面引入了一个外部样式表，和两个内联样式表，所以CSSOM对象中包含了3个CSSStylelSheet对象。

#### CSSStyleSheet

CSSStylelSheet对象又长什么样子呢？如下图所示：

![image-20180710203700519](/var/folders/np/g8g6bsy50p9c6qz76pytrb1m0000gn/T/abnerworks.Typora/image-20180710203700519.png)

CSSStyleSheet 对象主要包括下面的属性：

- type

  字符串 “text/css”

- href

  表示该样式表的来源，如果是内联样式，则href值为null

- parentStyleSheet

  父节点的styleSheet

- ownerNode

  该样式表所匹配到的DOM节点，如果没有则为空

- ownerRule

  父亲节点的styleSheet中的样式对本节点的合并

- media 

  该样式表中相关联的 MediaList

- title

  style 标签的title属性，不常见

  ```html
  <style title="papaya whip">
    body { background: #ffefd5; }
  </style>
  ```

- disabled

  是否禁用该样式表，可通过js控制该属性，从而控制页面是否应用该样式表

  

  

  

  



对于下面的css代码：

```css
p, img {
  background-color: peachpuff;
  color: gray;
}

div {
  background-color: beige;
  font-size: 1.5rem;
}
```

解析成的 CSSOM tree:

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180705_022905.png)

你会发现，有一个`CSSRuleList`, 里面的每一个元素都是`CSSStyleRule`，` CSSStyleRule`的 `selectorText` 是选择器，`CSSStyleDeclaration` 是样式。

每一个`CSSStyleDeclaration`节点里面会有所有可能出现的css 属性。对于没有指定样式的属性，其值为`""`。

### webkit's CSS Parser

webkit 使用 flex 和 bison 作为 `lexer` 和 `parser`

### 样式表的解析

浏览器的渲染引擎是从上往下进行解析的。

当渲染引擎遇到 `<style>` 节点的时候，会立马暂停解析`html`, 转而解析`CSS规则`，一旦`CSS规则`解析完成，渲染引擎会继续解析`html`

当渲染引擎遇到 `<link>`节点的时候，浏览器的网络组件会发起对 style 文件的请求，同时渲染引擎不会暂停，而是继续往下解析。等到 style 文件从服务器传输到浏览器的时候，渲染引擎立马暂停解析`html`, 转而解析`CSS规则`，一旦`CSS规则`解析完成，渲染引擎会继续解析`html`。

可以联想一下script的解析。

当渲染引擎遇到 `<script>` 节点的时候，会立马暂停解析`html`。

如果这个 `<script>` 节点是内联，则 JS 引擎会马上执行js代码，同时渲染引擎也暂停了工作。什么时候等 JS 代码执行完了，什么时候渲染引擎重新继续工作。如果JS 代码执行不完，那渲染引擎就继续等着吧。

如果这个 `<script>` 节点是外链的，浏览器的网络组件会发起对 script 文件的请求，渲染引擎也暂停了执行。什么时候等 JS 代码下载完毕，并且执行完了，什么时候渲染引擎重新继续工作。

在2011年的时候，浏览器厂商推出了“推测性”解析的概念。

“推测性”解析就是，当让渲染引擎干等着js代码下载和运行的时候，会起一个第三个进程，继续解析剩下的html。当js代码下载好了，准备开始执行js代码的时候，第三个进程就会马上发起对剩下html所引用的资源——图片，样式表和js代码的请求。

这样就节省了之后加载和解析时间。

被称为“推测性”解析是因为，前面的js代码存在一定的概率修改DOM节点，有可能会让后面的DOM节点消逝，那么我们的工作就白费了。浏览器“推测”这样的发生的概率比较小。

让渲染引擎干等着不工作是非常低效率的，所以雅虎军规会让把 script 标签放在body的底部。

言归正传，样式表放在head的前边，有两个原因：

1. 尽快加载样式表
2. 不要耽误js代码选择dom节点



## Render Tree

当浏览器忙着构建**DOM Tree**和 **CSSOM Tree**的时候,  浏览器同时将两者结合生成**Render Tree**。也就是说，浏览器构建**DOM Tree**和 **CSSOM Tree** ，和结合生成**Render Tree**，这两个是同时进行的。



### Render Forest

Levi Weintraub 在一次分享（[分享的视频点这里](https://mediaspace.msu.edu/media/How+WebKit+Renders+the+Web+-+Levi+Weintraub/1_p1nvwd0k)，[分享的ppt点这里](http://assets.en.oreilly.com/1/event/83/How%20WebKit%20Renders%20the%20Web%20Presentation.pdf)）中开玩笑说，准确的来说，应该是Render Forest (森林)。因为事实上，存在多条Render Tree:

- render object tree (稍后会详细讲解)
- layer tree
- inline box tree
- Style tee



### Render Object Tree

render object tree 是由 render object 节点构成的。render objec的节点的类是 RenderObject，定义在`webkit/Source/WebCore/rendering/RenderObject.h`

- owned by DOM tree(为DOM Tree 所有，但不是一对一对应的, 这一块也不太清楚)

- 只有当元素需要渲染的时候才会存在

  当设置`display:none` 时会销毁render object tree这一段

-  负责 layout 和 paint

- 负责查询DOM元素查询尺寸API

  比如说获取offsetHeight, offsetWidth的属性

对Render Object Tree的更直观的一张图：

![image-20180711153615199](http://p8cyzbt5x.bkt.clouddn.com/2018-07-11-073615.png)

上面左侧的DOM tree 中，左侧DOM tree的节点对应右侧Render Object Tree上的节点。细心的你会注意到，上图左侧的DOM Tree中的HTMLDivElement 会变成RenderBlock, HTMLSpanElement 会变成RenderInline，DOM节点对应的 render object 节点的类型并不一样，下面会介绍 render object 节点的类型。



#### render object 节点类型

我们在CSS中接触过文档流的概念，文档流中的元素分为块状元素和行内元素，比如说`div`是块状元素，`span `是行内元素。块状元素和行内元素在文档流中的表现不同，就是在选择render object 节点类型时决定的。

Render Object 的节点类型分为下面几种：

1. RenderBlock

   `display: block` 的DOM节点对应的render object节点类型为RenderBlock

2. RenderInline

   `display:inline` 的DOM节点对应的render object节点类型为RenderInline

3. RenderReplaced

   可能我们之前听说过“**替换元素**” 的概念，比如说常见的“替换元素”有下面：

   - `<iframe>`
   - `<video>`
   - `<embed>`
   - `<img>`

   为啥被称为“替换元素”，是因为他们的内容会被一个独立于HTML/CSS上下文的外部资源所替代。

   “替代元素” 的DOM节点对应的render object 节点类型为RenderReplaced

4. RenderTable

   `<table>` 元素的DOM节点对应的render object 节点类型为 RenderTable

5. RenderText

   文本内容的DOM节点对应的render object 的节点类型为 RenderText

#### Anonymous renderers

render object tree 遵守2个准则：

- 在文档流中的块状元素的子节点，要么都是块状元素，要么都是行内元素。
- 在文档流中的行内元素的子节点，只能都是行内元素。

我们的代码有时候不会准守这两种规则，如果出现不符合这两个准则的情况，会按照下面对步骤进行处理：

1. 在块状元素里面同时出现了块状元素和行内元素：

```html
<div>
  Some text
  <div>
    Some more text
  </div>
</div>
```

上面的代码中，最外层的div节点有两个子节点，第一个子节点是行内元素，第二个子节点是块状元素。render object tree 中会构建一个匿名的render object 节点去包裹 text 节点，因此上面的代码变成了下面的：

```html
<div>
  <anonymous block>
    Some text
  </anonymous block>
  <div>
   Some more text
  </div>
</div>
```



2. 还有另外一种非常糟糕的情况，就是在行内元素中出现了块状元素：

```html
<i>Italic only <b>italic and bold
  <div>
    Wow, a block!
  </div>
  <div>
    Wow, another block!
  </div>
More italic and bold text</b> More italic text</i>
```

上面的代码中，render object tree需要做更多的事情去修复这种糟糕的DOM tree: 三个匿名的block会被创建，上面的代码会被分割成三段，被三个匿名的block 包裹。

```html
<anonymous pre block>
  <i>Italic only <b>italic and bold</b></i>
</anonymous pre block>

<anonymous middle block>
  <div>
  Wow, a block!
  </div>
  <div>
  Wow, another block!
  </div>
</anonymous middle block>

<anonymous post block>
  <i><b>More italic and bold text</b> More italic text</i>
</anonymous post block>
```

注意到，`<i>` 元素和 `<b>` 元素都被分割进了`<anonymous pre block>` 和 `<anonymous post block>` 两个类型为 RenderBlock 的 render object 节点中，他们通过一种叫*continuation chain（延续链）*的机制来链接。

负责上面递归拆分行内元素的生产*continuation chain（延续链）*的方法被称为 `splitFlow`。



blog

https://webkit.org/blog/115/webcore-rendering-ii-blocks-and-inlines/

video

https://mediaspace.msu.edu/media/How+WebKit+Renders+the+Web+-+Levi+Weintraub/1_p1nvwd0k



### 什么是 Render Tree

**Render Tree** 的节点由那些可以被展示的元素组成，元素的顺序是按照被展示的顺序排列。

**Render Tree** 上面的节点元素在不同的浏览器叫法不同，在**webkit**中被称为 `renderer`, 或者 被称为 `render objects`, 这篇文章中，在firfox中，被称为`frames`。 我们统一叫法是 **Render Tree **的节点。需要注意的是， **Render Tree **的节点都长方形。

webkit 有一个类`RenderObject.h`， 这个是所有 **Render Tree **的节点对象的父类。

下面是`RenderObject.h`的简化版本：

```java
// Credit to Tali Garsiel for this simplified version of WebCore's RenderObject.h
class RenderObject {
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;  // 这个render tree的节点所指向的那个Dom节点
  RenderStyle* style;  // 这个render tree节点的计算出来的样式
  RenderLayer* containingLayer;  // 包含这个 render tree 的 z-index layer
}
```

`RenderBox` 是`RenderObject`的一个子类，它主要是负责DOM树上的每一个节点的盒模型。

`RenderBox` 包括一些计算好尺寸的信息，比如说：

- `height`
- `width`
- `padding`
- `border`
- `margin`
- `clientLeft`
- `clientTop`
- `clientWidth`
- `clientHeight`
- `offsetLeft`
- `offsetTop`
- `offsetWidth`
- `offsetHeight`
- `scrollLeft`
- `scrollTop`
- `scrollWidth`
- `scrollHeight`

 `RenderBox`也有自己的子类： `RenderInline`,、`RenderBlock`、 `RenderListItem`等等。

对于一个节点来说，究竟选择哪个子类有很多因素决定，最主要的元素是 `display` 的值，如果是`display:inline` ，那么就选择 `RenderInline `盒子，如果是 `display:block`,  那么就选择 `RenderBlock` 盒子, 下面就是webkit 进行选择的代码。

```
RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
    Document* doc = node->document();
    RenderArena* arena = doc->renderArena();
    ...
    RenderObject* o = 0;

    switch (style->display()) {
        case NONE:
            break;
        case INLINE:
            o = new (arena) RenderInline(node);
            break;
        case BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case INLINE_BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case LIST_ITEM:
            o = new (arena) RenderListItem(node);
            break;
       ...
    }

    return o;
}
```

`

### Render Tree===Dom Tree?

**Render Tree** 并不严格等于**Dom Tree**，比如说在下面这几种情况的时候，这两者就不等于对方。

#### 1. `display : none` 的DOM 接单没有对应的 Render Tree 的节点

这里的`display:none ` 属性，有可能是我们在CSS里面设置的，也有可能是浏览器默认的添加的属性。比如说下面的元素就会有默认的`display:none`的属性。

- `<head>`
- `<meta>`
- `<link>`
- `<script>`

#### 2. 一个DOM节点，可能有多个 Render Tree的节点

下面的各个DOM元素，会对应多个Render Tree的节点

- `<input type="**color**">`

- `<input type="**date**">`

- `<input type="**file**">`

- `<input type="**range**">`

- `<input type="**radio**">`

- `<input type="**checkbox**">`

- `<select>`

  比如说，`<input type="range">` 就会有两个renderer：

  ![](http://p8cyzbt5x.bkt.clouddn.com/UC20180705_112633.png)

  `<input type="color">` 对应的renderer 就更多了。

  ![](https://cdn-images-1.medium.com/max/1600/1*kdVDk1r0RGjcxqey2EJmmw.gif)

#### 3. 脱离了文档流的DOM节点，DOM Tree 和 Render Tree 是对应不上的。

脱离文档流的情况，要么是`float`, 要么是`position: absolute / fixed`。

比如说对于下面的结构：

```html
<body>
  <div>
    <p>Lorem ipsum</p>
  </div>
</body>
```

它的 `DOM tree`和 `Render Tree` 如下图所示：

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180705_113224.png)



如果增加脱离文档流的样式，如下：

```
p {
  position: absolute;
}
```

情况就会变成下面这样：

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180705_113403.png)

`<p>` 节点对应的 Render Tree 的节点，从父节点脱离出来，挂到了顶部的`RenderView` 节点下面。

### 构建 Render Tree 

**Gecko** 和 **webkit** 采用了不同的方案来构建 **Render Tree**。

**Gecko** 是把样式计算和构建Render Tree 的工作代理到 `FrameConstructor` 对象上。而 webkit 采用的方案是，每一个DOM节点自己计算自己的样式，并且构建自己 的Render-tree 对应的节点。

**Gecko** 针对DOM的更新增加了一个 **listener**，当DOM 更新的时候，更新的DOM节点被传到一个指定的对象`FrameConstructor`,  这个`FrameConstructor` 会为 DOM 节点计算样式，同时为这个DOM节点创建一个合适的 **Render-Tree节点**。

 **webkit**构建 **Render-tree** 的过程被称为`attachment`, 每一个DOM节点被赋予一个 `attach()` 方法，这是一个同步的方法，当每一个DOM节点被插入DOM树的时候，  该DOM节点的`attach() `方法就会被调用。

### 样式计算

在构建Render Tree的时候，需要进行样式计算，也就是Render Tree每一个节点都需要有一个**visual information**的信息，才可以被绘制在屏幕上，这就需要样式计算这一过程。

而样式计算需要两部分“原材料”：

1. DOM Tree
2. 一堆样式规则

DOM Tree在HTML解析之后就可以拿到了，一堆样式规则可以来自下面：

- 浏览器默认的样式
- 外链样式
- 内联样式
- DOM节点上的style属性

那么样式规则是如何构成的呢？

- 样式表是一堆  **规则（rules**）的集合；
- 当然也不光都是 **规则（rules）**, 还会有一些奇怪的东西：@import, @media, @namespace 等等
- 一个**规则（rules）**是由**选择器（selector）**和**声明块（declaration block）**构成的
- **声明块（declaration block）**由一堆**声明（declaration）**加中括号构成
- **声明（declaration ** 由 property 和 value 构成。 



![image-20180710105250958](/var/folders/np/g8g6bsy50p9c6qz76pytrb1m0000gn/T/abnerworks.Typora/image-20180710105250958.png)**





#### 样式规则的应用顺序

某一个DOM节点上可能有多个规则，比如下下面：

```
div p {
  color: goldenrod;
}
p {
  color: red;
}
```

那么这个DOM节点究竟用的是哪个规则？

规则的权重是：先看 order , 然后再算specificity, 最后再看哪个规则靠的更近。

##### order

order的权重从高到底：

1. 用户的 `! important 声明`（浏览器可以让用户导入自定的样式）
2. 程序员写的 ! important 声明
3. 程序员写的普通css样式
4. 浏览器的默认css样

##### Specificity

Specificity是一个相加起来的值

```
#foo .bar > [name="baz"]::first-line {}   /* Specificity: 0 1 2 1 */
```

1. 第一位的数值（a）

   是否有DOM节点上style属性的值，有则是1，否则是0

2. 第二位的数值 (b)

   id选择器的数量之和

3. 第三位的数值 (c)

   class选择器，属性选择器，伪类选择器个数之和

4. 第四位的数值 (d)

   标签选择器，伪元素选择器个数之和

下面是例子：

```
 *             {}  /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */
 li            {}  /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */
 li:first-line {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul li         {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul ol+li      {}  /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */
 h1 + *[rel=up]{}  /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */
 ul ol li.red  {}  /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */
 li.red.level  {}  /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */
 #x34y         {}  /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */
 style=""          /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */
```





样式的计算存在以下三个难点：

1. style 样式数据太多，会占用大量内存
2. 匹配元素会影响性能
3. css规则的应用顺序

下面我们介绍这个三个难点是如何解决的。

#### style 样式数据太多，会占用大量内存

这里的style样式数据太多，不是说我们写的css样式太多，而是Render Tree每一个节点上都需要存储全部的CSS样式，那些没有被指定的样式，其值为继承父节点的样式，或者是浏览器的默认样式，或者干脆是个空值。

webkit 和 gecko 采用了不同的解决方案。

##### webkit：共享样式数据

WebKit 的解决方案是，节点们会引用**RenderStyle**对象。这些对象在以下情况下可以由不同的DOM节点共享，从而节省空间和提高性能。

- 这些节点是同级关系
- 这些节点有相同的伪类状态：hover、：active、：focus
- 这些节点都没有id
- 这些节点有相同的tag名称
- 这些节点有相同的class
- 这些节点都没有通过style属性设置的样式
- 这些节点没有一个是使用 兄弟选择器的，比如说： `div + p`, `div ~ p`, `:last-child`, `:first-child`, `:nth-child()`, `:nth-of-type()`

##### Gecko：style struct sharing

Gecko 采用了一种 **style struct sharing** 的机制。有一些css属性可以聚合在一起，比如说font-szie, font-family, color 等等，浏览器就把这些可以被划分为一组的属性，单独的保存到一个对象里面，这个对象被称为 **style struct**。如下表所示：

![image-20180705203212950](http://p8cyzbt5x.bkt.clouddn.com/2018-07-05-123213.png)

上图中的，**computed style** 里就不用存储CSS全部的200多个属性，而是保存着对这些 **style struct**对象的引用。

这样一来，一些具有相同属性的DOM 节点就可以引用相同的 `style struct`， 不仅如此，因为子节点有一些属性会继承父节点，那么保存这些属性的 `style struct` 就会被父节点和子节点所共享。

#### 匹配元素会影响性能

对于每一个DOM节点，css引擎需要去遍历所有的css规则看是否匹配。对于大部分的DOM节点，css规则的匹配并不会发生改动。

比如说，用户把鼠标hover到一个父元素上面，这个父元素的css规则匹配是发生了变化，我们不仅仅要重新计算这个父元素的样式，还需要重新计算这个父元素的子元素的样式（因为要处理继承的样式），但是能匹配这些子元素的样式规则，是不会变的。

如果我们能记下来，有哪些selector可以匹配到就好了。

因此，为了优化，CSS 引擎在进行 selector 匹配时，会根据权重的顺序把他们排成一串，然后把这一串加到右边的 CSS rule tree 上面。

![image-20180706013726314](http://p8cyzbt5x.bkt.clouddn.com/2018-07-05-173726.png)

CSS引擎希望右边CSS rule tree 的分支数越少越好，因此会将新加入的一串尽量的合并到已有的分支，所以上面的过程会是下面这样的：

![image-20180706013959120](http://p8cyzbt5x.bkt.clouddn.com/2018-07-05-173959.png)

然后遍历每一个DOM节点去找能匹配到的CSS Rule Tree的分支，从CSS rule Tree的底部开始，一路向上开始匹配，直到找到对应的那一条 style rule Tree分支。这就是人们口中常说的，css选择器是从右边匹配的。

当浏览器因为某种原因（用户交互，js修改DOM）进行重新渲染的时候，CSS引擎会快速检查一下，对父节点的改动是否会影响到子节点的 selector 匹配，如果不影响，CSS引擎就直接拿到每一个子节点对CSS rule Tree 对应那个分支的指针，节省掉匹配选择器的时间。

尽管如此，我们还是需要在第一次遍历每一个DOM节点去找到对应的CSS Rule Tree的分支。如果我们有10000个相同的节点，就需要遍历10000次。

Gecko 和 Webkit 都对此进行了优化，在遍历完一个节点之后，会把计算好的样式放到缓存中，在遍历下一个节点之前，会做一个判断，看是否可以复用缓存中的样式。

这个判断包括一下几点：

1. 两个节点是否有相同的id, class 

2. 两个节点是否有相同的style 属性

3. 两个节点对应的父亲节点是否共享一份计算好的样式，那该两个节点继承的样式也是相同的。

   ![image-20180706021216963](http://p8cyzbt5x.bkt.clouddn.com/2018-07-05-181217.png)



## 解析阶段如何优化

css解析会让js变慢。虽然浏览器有ui线程来处理css的渲染，js执行线程。看起来css的性能问题不会影响到js。

但是浏览器的这两个线程是互斥的，当ui线程执行时，会冻住js线程的执行。

原因是因为，ui渲染的结果会影响到js获取dom的结果（比如说css中display为none, js 就获取不到了），同样的，js 线程也会影响到ui的渲染，所以这两个线程是互斥的。

如果layout 和 repaint 被频繁触发，ui渲染频繁，最终会影响到js的执行，甚至导致页面卡死。

### 选择器的优化

不同的选择器，匹配的效率会有差距，但是差距不大。

我们用一个有1000个DOM节点的页面来测试，分别在5个浏览器中尝试以下20种匹配器：

```
	1. Data Attribute (unqualified)
	*/
	[data-select] {
		color: red;
	}

	/*
		2. Data Attribute (qualified)
	

	a[data-select] {
		color: red;
	}
	*/
	

	/*
		3. Data Attribute (unqualified with value)
	

	[data-select="link"] {
		color: red;
	}
	*/


	/*
		4. Data Attribute (qualified with value)
	

	a[data-select="link"] {
		color: red;
	}
	*/


	/*
		5. Multiple Data Attributes (qualified with values)
	

	div[data-div="layer1"] a[data-select="link"] {
		color: red;
	}
	*/


	/*
		6. Solo Pseudo selector
	

	a:after {
		content: "after";
		color: red;
	}
	*/


	/*
		7. Combined classes
	

	.tagA.link {
		color: red;
	}
	*/


	/*
		8. Multiple classes 
	

	.tagUl .link {
		color: red;
	}
	*/


	/*
		9. Multiple classes (using child selector)
	
	.tagB > .tagA {
		color: red;
	}
	*/


	/*
		10. Partial attribute matching

	[class^="wrap"] {
		color: red;
	}	
	*/


	/*
		11. Nth-child selector
	
	.div:nth-of-type(1) a {
		color: red;
	}
	*/


	/*
		12. Nth-child selector followed by nth-child selector
	
	.div:nth-of-type(1) .div:nth-of-type(1) a {
		color: red;
	}
	*/


	/*
		13. Insanity selection (unlucky for some)
	
	div.wrapper > div.tagDiv > div.tagDiv.layer2 > ul.tagUL > li.tagLi > b.tagB > a.TagA.link {
		color: red;
	}
	*/


	/*
		14. Slight insanity
	
	.tagLi .tagB a.TagA.link {
		color: red;
	}
	*/


	/*
		15. Universal
	
	* {
		color: red;
	}
	*/


	/*
		16. Element single
	
	a {
		color: red;
	}
	*/


	/*
		17. Element double
	
	div a {
		color: red;
	}
	*/


	/*
		18. Element treble
	
	div ul a {
		color: red;
	}
	*/


	/*
		19. Element treble pseudo
	
	div ul a:after; {
		content: "after";
		color: red;
	}
	*/


	/*
		20. Single class
	
	.link {
		color: red;
	}
```

测试的结果如下：

| Test          | Chrome 34 | Firefox 29 | Opera 19 | IE9   | Android 4 |
| ------------- | --------- | ---------- | -------- | ----- | --------- |
| 1             | 56.8      | 125.4      | 63.6     | 152.6 | 1455.2    |
| 2             | 55.4      | 128.4      | 61.4     | 141   | 1404.6    |
| 3             | 55        | 125.6      | 61.8     | 152.4 | 1363.4    |
| 4             | 54.8      | 129        | 63.2     | 147.4 | 1421.2    |
| 5             | 55.4      | 124.4      | 63.2     | 147.4 | 1411.2    |
| 6             | 60.6      | 138        | 58.4     | 162   | 1500.4    |
| 7             | 51.2      | 126.6      | 56.8     | 147.8 | 1453.8    |
| 8             | 48.8      | 127.4      | 56.2     | 150.2 | 1398.8    |
| 9             | 48.8      | 127.4      | 55.8     | 154.6 | 1348.4    |
| 10            | 52.2      | 129.4      | 58       | 172   | 1420.2    |
| 11            | 49        | 127.4      | 56.6     | 148.4 | 1352      |
| 12            | 50.6      | 127.2      | 58.4     | 146.2 | 1377.6    |
| 13            | 64.6      | 129.2      | 72.4     | 152.8 | 1461.2    |
| 14            | 50.2      | 129.8      | 54.8     | 154.6 | 1381.2    |
| 15            | 50        | 126.2      | 56.8     | 154.8 | 1351.6    |
| 16            | 49.2      | 127.6      | 56       | 149.2 | 1379.2    |
| 17            | 50.4      | 132.4      | 55       | 157.6 | 1386      |
| 18            | 49.2      | 128.8      | 58.6     | 154.2 | 1380.6    |
| 19            | 48.6      | 132.4      | 54.8     | 148.4 | 1349.6    |
| 20            | 50.4      | 128        | 55       | 149.8 | 1393.8    |
| Biggest Diff. | 16        | 13.6       | 17.6     | 31    | 152       |
| Slowest       | 13        | 6          | 13       | 10    | 6         |

**解释**

在浏览器的引擎内部，这些选择器会被重新的拆分，组合，优化，编译。而不同的浏览器内核采用不同的方案，所以几乎没有办法预测，选择器的优化究竟能带来多少收益。

**结论：** 

合理的使用选择器，比如说层级更少的class，的确会提高匹配的速度，但是速度的提高是有限的 。

如果你通过dev tool 发现匹配选择器的确是瓶颈，那么就选择优化它。

### 精简没有用的样式代码

大量无用代码会拖慢浏览器的解析速度。

用一个3000行的无用css样式表和1500行的无用样式表，进行测试：

| Test | Chrome 34 | Firefox 29 | Opera 19 | IE9   | Android 4 |
| ---- | --------- | ---------- | -------- | ----- | --------- |
| 3000 | 64.4      | 237.6      | 74.2     | 436.8 | 1714.6    |
| 1500 | 51.6      | 142.8      | 65.4     | 358.6 | 1412.4    |

对于火狐来说，在其他环节一致的情况下，页面渲染的速度几乎提升了一倍 

尽管现在的惯例是把css 打包成一个巨大单一的css文件。这样做的确是有好处的，减少http请求的数量。但是拆分css文件可以让加载速度更快，浏览器的解析速度更快。

这一项的优化是非常显著的，通常可以省下来 2ms ~ 300ms的时间。

精简的过程可以使用uncss 工具来自动化的完成。

### 避免使用耗性能的属性

可以点击这个链接进行测试[测试连接](https://benfrain.com/selector-test/3-01.html)

```
.link {
    background-color: red;
    border-radius: 5px;
    padding: 3px;
    box-shadow: 0 5px 5px #000;
    -webkit-transform: rotate(10deg);
    -moz-transform: rotate(10deg);
    -ms-transform: rotate(10deg);
    transform: rotate(10deg);
    display: block;
}
```

测试结果：

| Test             | Chrome 34 | Firefox 29 | Opera 19 | IE9   | Android 4 |
| ---------------- | --------- | ---------- | -------- | ----- | --------- |
| Expensive Styles | 65.2      | 151.4      | 65.2     | 259.2 | 1923      |

需要注意的是，高耗css样式如果不会频繁的触发回流和重绘，只会在页面渲染的时候被执行一次，那么对页面的性能影响是有限的。如果频繁的触发回流和重绘，那么最基本的css样式也会影响到页面的性能。

那么哪些 css 样式会造成页面性能的问题呢？

- Border-radius
- Shadow
- gradients
- transform rotating

更多的内容请参考 [连接](http://perfectionkills.com/profiling-css-for-fun-and-profit-optimization-notes/)



# 第二步：layout

我们拿到了Render Tree, 但是我们还没有这个元素的位置和尺寸。这一步是在layout的环节完成的。

我们能在不同的文章中看到不同的名词： ` 布局 ` ，` layout ` ,  ` 回流 ` ， ` reflow ` , 这些名词说的都是一回事，不同浏览器的叫法不同。

HTML是流式的布局，从上往下，从左往右， 后面的元素的改动不会影响到前面的改动。

每一个节点都有一个layout() 方法，首先是根节点被安顿好，然后子节点对layout() 方法被一次调用。



需要注意的是，layout 必然会触发 paint , 但是 paint 不一定会触发layout 。所以相比于layout + repaint的代价，还是单纯的 repaint 代价更小一些。

## 会触发layout 的属性

1. 盒子模型相关的属性

   - width 

   - height

   - padding

   - margin

   - border

   - display

   - ###### ……

2. 定位属性和浮动

   - top
   - bottom
   - left
   - right
   - position
   - float
   - clear

3. 节点内部的文字结构

   - text - aligh
   - overflow
   - font-weight
   - font- family
   - font-size
   - line-height



上面只是一部分，更全部的可以点击 [csstriggers](https://csstriggers.com/) 来查阅；

csstrigger 里面需要注意的有几点。

1. opacity的改动，在blink内核和Gecko内核上不会触发layout 和 repaint ![image-20180706152622532](http://p8cyzbt5x.bkt.clouddn.com/2018-07-06-072622.png)

2.  transform的改动，在blink内核和Gecko内核上不会触发layout 和 repaint 

   ![image-20180706152905325](http://p8cyzbt5x.bkt.clouddn.com/2018-07-06-072905.png)

3. visibility 的改动，在Gecko 内核上不会触发 layout repaint, 和 composite![image-20180706153256502](http://p8cyzbt5x.bkt.clouddn.com/2018-07-06-073256.png)



## 会触发layout 的方法

几乎任何测量元素的宽度，高度，和位置的方法都会不可避免的触发reflow, 包括但是不限于：

- elem.getBoundingClientRect()
- window.getComputedStyle()
- window.scrollY
- and a lot more…



## 如何避免重复Layout

#### 不要频繁的增删改查DOM

#### 不要频繁的修改默认根字体大小

#### 不要一条条去修改DOM样式，而是通过切换className

虽然切换className 也会造成性能上的影响，但是次数上减少了。

#### “离线”修改DOM

比如说一定要修改这个dom节点100次，那么先把dom的display设置为 none ( 仅仅会触发一次回流 )

#### 使用flexbox

老的布局模型以相对/绝对/浮动的方式将元素定位到屏幕上 Floxbox布局模型用流式布局的方式将元素定位到屏幕上，flex性能更好。

#### 不要使用table

使用table布局哪怕一个很小的改动都会造成重新布局

#### 避免强制性的同步layout

layout根据区域来划分的，分为全局性layout, 和局部的layout。比如说修改根字体的大小，会触发全局性layout。

全局性layout是同步的，会立刻马上被执行，而局部性的layout是异步的，分批次的。浏览器会尝试合并多次局部性的layout为一次，然后异步的执行一次，从而提高效率。

但是js一些操作会触发强制性的同步布局，从而影响页面性能，比如说读取 offsetHeight、offsetWidth 值的时候。





# 第三步：paint

第三个阶段是paint 阶段

## 会触发paint 的属性

- color
- border - style
- border - radius
- visibility
- Text -decoration
- background
- background
- Background - image
- background - size 
- Background - repeat
- background - position
- outline - color 
- outline
- outline - style
- outline - width 
- box - shadow

## 如何避免触发paint

#### 使用transform代替top, left 的变化

使用transform不会触发layout , 只会触发paint。

如果你想页面中做一些比较炫酷的效果，相信我，transform可以满足你的需求。

```
// 位置的变换
transform: translate(1px,2px)

// 大小的变换
transform: scale(1.2)
```

#### 使用opacity 来代替 visibility

因为 visibility属性会触发重绘，而opacity 则不会触发重绘







# 第四步：composite

## 什么是合成层

上面几个阶段可以用下面一张图来表示：

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180619_172713.png)

#### 1. 从 Nodes 到 LayoutObjects

DOM 树每个 Node 节点都有一个对应的 LayoutObject 。LayoutObject 知道如何在屏幕上 paint Node 的内容。

#### 2. 从 LayoutObjects 到 PaintLayers

有相同坐标的  **LayoutObjects** ，在同一个**PaintLayer**内。 根据创建**PaintLayer** 的原因不同，可以将其分为常见的 3 类：

1. NormalPaintLayer

- 根元素
- relative、fixed、sticky、absolute
- opacity 小于 1
- CSS 滤镜（fliter）
- 有 CSS mask 属性
- 有 CSS mix-blend-mode 属性（不为 normal）
- 有 CSS transform 属性（不为 none）
- backface-visibility 属性为 hidden
- 有 CSS reflection 属性
- 有 CSS column-count 属性（不为 auto）或者 有 CSS column-width 属性（不为 auto）
- 当前有对于 opacity、transform、fliter、backdrop-filter 应用动画

2. OverflowClipPaintLayer

- overflow 不为 visible

3. NoPaintLayer

- 不需要 paint 的 PaintLayer，比如一个没有视觉属性（背景、颜色、阴影等）的空 div。

#### 4. 从 PaintLayers 到 GraphicsLayers

某些特殊的**paintLayer**会被当成合成层,合成层拥有单独的 GraphicsLayer，而其他不是合成层的**paintLayer**，则和其第一个拥有GraphicsLayer 父层公用一个。

每个 **GraphicsLayer** 都有一个**GraphicsContext**，**GraphicsContext** 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由
GPU 将多个位图进行合成，然后 draw 到屏幕上，此时，我们的页面也就展现到了屏幕上。

## 渲染层提升为合成层的原因

渲染层提升为合成层的原因有一下几种：

- 直接原因
  - 硬件加速的 iframe 元素（比如 iframe 嵌入的页面中有合成层
  - video元素
  - 3d transiform
  - 在 DPI 较高的屏幕上，fix 定位的元素会自动地被提升到合成层中。但在 DPI 较低的设备上却并非如此
  - backface-visibility 为 hidden
  - 对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要注意的是 active 的 animation 或者
    transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）
  - will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）
- 后代元素原因
  - 有合成层后代同时本身有 transform、opactiy（小于 1）、mask、fliter、reflection 属性
  - 有合成层后代同时本身 overflow 不为 visible（如果本身是因为明确的定位因素产生的 SelfPaintingLayer，则需要 z-index 不为 auto）
  - 有合成层后代同时本身 fixed 定位
  - 有 3D transfrom 的合成层后代同时本身有 preserves-3d 属性
  - 有 3D transfrom 的合成层后代同时本身有 perspective 属性
- overlap 重叠原因

> 为啥overlap 重叠也会造成提升合成层渲染? 图层之间有重叠关系，需要按照顺序合并图层。



## 如何优化

如果把一个频繁修改的dom元素，抽出一个单独的图层，然后这个元素的layout, paint 阶段都会在这个图层进行，从而减少对其他元素的影响。

### 使用will-change 或者 transform3d

使用 ` will-change `  或者 ` transform3d `

```
1. will-change: transform/opacity
 2. transform3d(0,0,0,)
```

### 使用加速视频解码的<video>节点

因为视频中的每一帧都是在动的，所以视频的区域，浏览器每一帧都需要重绘。所以浏览器会自己优化，把这个区域的给抽出一个单独的图层

### 拥有3D(webgl) 上下文或者加速的2D上下文的<canvas>节点

### 混合插件（flash）

### 如果某一个元素，通过z-index在复合层上面渲染，则该元素也会被提升到复合层

>  需要注意的是，gif 图片虽然也变化很频繁，但是 img 标签不会被单独的提到一个复合层，所以我们需要单独的提到一个独立独立的图层之类。

composite更详尽的知识可以了解下面这个博客： [《GPU Accelerated Compositing in Chrome》](http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome)





# 优化实践

## Bounce-btn优化

bounce-btn是类似于下面这种的：

![](http://h0.hucdn.com/open/201827/cf9e7e8485554311_326x560.gif)



如果想实现这种效果，假设不考虑性能问题，写出下面的代码话：

```html
    <div class="content-box"></div>
    <div class="content-box"></div>
    <div class="content-box"></div>
    <div class="bounce-btn"></div>
    <div class="content-box"></div>
    <div class="content-box"></div>
    <div class="content-box"></div>
```

```css
.bounce-btn {
  width: 200px;
  height: 50px;
  background-color: antiquewhite;
  border-radius: 30px;
  margin: 10px auto;
  transition: all 1s;
}
.content-box {
  width: 400px;
  height: 200px;
  background-color: darkcyan;
  margin: 10px auto;
}
```

```js
let btnArr = document.querySelectorAll('.bounce-btn');
setInterval(() => {
  btnArr.forEach((dom) => {
    if ( dom.style.width ==='200px') {
      dom.style.width = '300px';
      dom.style.height = '70px';
    } else {
      dom.style.width = '200px';
      dom.style.height = '50px';
    }
  })
},2000)
```

可以发现这样的性能是非常差的，我们打开dev-tool的**paint flashing**， 发现重新渲染的区域如绿色的区域所示：

![](http://h0.hucdn.com/open/201827/591b01b9044226bc_324x434.gif)

而此时的性能是，1000ms 的时间内，layout阶段花费了29.9ms占了18.6%

![image-20180706144354901](http://p8cyzbt5x.bkt.clouddn.com/2018-07-06-064355.png)

![image-20180706144409030](http://p8cyzbt5x.bkt.clouddn.com/2018-07-06-064409.png)

这个其实有两个地方，第一是，**bounce btn** 这个元素被js 修改了width 、height 这些属性，从而触发了自身**layout** ——> **repaint** ——> **composite**。第二是，**bounce btn** 没有脱离文档流，它自身布局的变化，影响到了它下面的元素的布局，从而导致下面元素也触发了**layout** ——> **repaint** ——> **composite**。



那么我们把**修改width**, 改为 **tansform: scale()**

```js
let btnArr = document.querySelectorAll('.bounce-btn');
setInterval(() => {
  btnArr.forEach((dom) => {
    if ( dom.style.transform ==='scale(0.8)') {
      dom.style.transform = 'scale(2.5)';
    } else {
      dom.style.transform = 'scale(0.8)';
    }
  })
},2000)
```

页面性能得到了提高：

![](http://h0.hucdn.com/open/201827/35abe8580e1b9a26_324x434.gif)

重新渲染的区域只有它自身了。此时的性能是，1000ms 的时间内，没有存在layout阶段，

![image-20180706145450446](http://p8cyzbt5x.bkt.clouddn.com/2018-07-06-065450.png)

![image-20180706145652251](http://p8cyzbt5x.bkt.clouddn.com/2018-07-06-065652.png)



如果继续优化，我们通过aimation动画来实现bounce的效果：

```css
        @keyframes bounce {
            0% {
                transform: scale(0.8);
            }
            25% {
                transform: scale(1.5);
            }
            50% {
                transform: scale(1.5);
            }
            75% {
                transform: scale(1.5);
            }
            100% {
                transform: scale(0.8);
            }
        }
```

页面中没有重新渲染的区域：

![](http://h0.hucdn.com/open/201827/6fcfc1ded9655cf8_326x532.gif)

并且页面性能几乎没有受到任何影响，不会重新经历 layout ——> repaint ——> composite.

![image-20180706150428460](http://p8cyzbt5x.bkt.clouddn.com/2018-07-06-070429.png)



![image-20180706150438553](http://p8cyzbt5x.bkt.clouddn.com/2018-07-06-070438.png)

所以，对于这种动效，优先选择 CSS animation >  transform 修改 scale >  绝对定位 修改width > 文档流中修改width



## 跑马灯的优化

跑马灯的动效是：每隔3秒进行向左侧滑动淡出，然后再滑动重新淡入，更新文本为“**砍价9元”

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180620_171827.png)

之前的滑动和淡出的效果是通过vue提供的 ` <transision> ` 来实现的

### ` <transision> ` 原理

当我们想要用到过渡效果，会在vue中写这样的代码：

```
<transition name="toggle">
  <div class="test">
</transition>
```

但是其实渲染到浏览器中的代码，会依次是下面这样的：

```
// 过渡进入开始的一瞬间
<div class="test toggle-enter">

// 过渡进入的中间阶段
<div class="test toggle-enter-active">

// 过渡进入的结束阶段
<div class="test toggle-enter-active toggle-enter-to">


// 过渡淡出开始的一瞬间
<div class="test toggle-leave">

// 过渡淡出的中间阶段
<div class="test toggle-leave-active">

// 过渡淡出的结束阶段
<div class="test toggle-leave-active toggle-leave-to">
```

也就是说，过渡效果的实现，是通过不停的修改、增加、删除该dom节点的class来实现。

### ` <transision> ` 影响页面性能

一方面， ` v-if ` 会修改dom节点的结构，修改dom节点会造成浏览器重走一遍 ` layout ` 阶段，也就是重排。另一方面，dom节点的class被不停的修改，也会导致浏览器的重排现象，因此页面性能会比较大的受到影响。

若页面中 ` <transition> ` 控制的节点过多时，页面的性能就会比较受影响。

为了证明，下面代码模拟了一种极端的情况：

```
<div v-for="n in testArr">
  <transition name="toggle">
    <div class="info-block" v-if="isShow"></div>
  </transition>
</div>
```

```
  export default {
  	data () {
          return {
            isShow: false,
            testArr: 1000
          }
    },
    methods: {
	    toggle() {
	    	var self = this;
	    	setInterval(function () {
		      self.isShow = !self.isShow
	      }, 1000)
      }
    },
    mounted () {
	 this.toggle()
    }
  }
```

```
  .toggle-show-enter {
    transform: translate(-400px,0);
  }

  .toggle-show-enter-active {
    color: white;
  }

  .toggle-show-enter-to {
    transform: translate(0,0);
  }

  .toggle-show-leave {
    transform: translate(0,0);
  }

  .toggle-show-leave-to {
    transform: translate(-400px,0);
  }

  .toggle-show-leave-active {
     color: white;
  }
```

上面的代码在页面中渲染了 ` 1000 ` 个过渡的元素，这些元素会在1秒的时间内从左侧划入，然后划出。

此时，我们打开google浏览器的开发者工具，然后在 ` performance ` 一栏中记录分析性能，如下图所示：

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180620_184927.png)

可以发现，页面明显掉帧了。在7秒内，总共 ` scripting ` 的阶段为3秒， ` rendering ` 阶段为1956毫秒。

事实上，这种跑马灯式的重复式效果，通过 ` animation ` 的方式也可以轻松实现。 我们优化上面的代码，改为下面的代码，通过 ` animation ` 动画来控制过渡：

```
    <div v-for="n in testArr">
      <div class="info-block"></div>
    </div>
```

```
  export default {
  	data () {
  	  return {
            isShow: false,
            testArr: 1000
      }
    }
  }
```

```
.info-block {
  background-color: red;
  width: 300px;
  height: 100px;
  position: fixed;
  left: 10px;
  top: 200px;
  display: flex;
  align-items: center;
  justify-content: center;
  animation: toggleShow 3s ease 0s infinite normal;
}

@keyframes toggleShow {
  0% {
    transform: translate(-400px);
  }
  10% {
    transform: translate(0,0);
  }
  80% {
    transform: translate(0,0);
  }
  100% {
    transform: translate(-400px);
  }
}
```

打开浏览器的开发者工具，可以在 ` performance ` 里面看到，页面性能有了惊人的提升：

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180620_194504.png)

为了进一步提升页面的性能，我们给过渡的元素增加一个 ` will-change ` 属性，该元素就会被提升到 ` 合成层 ` 用GPU单独渲染，这样页面性能就会有更大的提升。



## 优化懒加载（需考虑兼容性）

有一些页面使用了懒加载，懒加载是通过绑定 ` scroll ` 事件一个回调事件，每一次调用一次回调事件，就会测量一次元素的位置，调用 ` getBoundingClientRect() ` 方法，从而计算出是否元素出现在了可视区。

```
// 懒加载库中的代码，判断是否进入了可视区
const isInView = (el, threshold) => {
  const {top, height} = el.getBoundingClientRect()
  return top < clientHeight + threshold && top + height > -threshold
}
```

### ` scroll ` 造成页面性能下降

 ` scroll ` 事件会被重复的触发，每触发一次就要测量一次元素的尺寸和位置。尽管对 ` scroll ` 的事件进行了节流的处理，但在低端安卓机上仍然会出现滑动不流畅的现象。

优化的思路是通过新增的api—— ` IntersectionObserver ` 来获取元素是否进入了可视区。

### 使用` intersection observer `

 ` intersection observer api ` 可以去测量某一个dom节点和其他节点，甚至是viewport的距离。

这个是实验性的api，你应该查阅https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#Browser_compatibility查看其兼容性

在过去，检测一个元素是否在可视区内，或者两个元素之间的距离如何，是一个非常艰巨的任务。 但获取这些信息是非常必要的：

1. 用于懒加载
2. 用于无限加载，就是微博那种刷到底接着请求新数据可以接着刷
3. 检测广告的可见性

在过去，我们需要不断的调用 ` Element.getBoundingClientRect() ` 方法去获取到我们想拿到的信息，然而这些代码会造成性能问题。

 ` intersection observer api ` 可以注册回调函数，当我们的目标元素，进入指定区域（比如说viewport，或者其他的元素）时，回调函数会被触发；

### ` intersectionObserver ` 的语法

```
  var handleFun = function() {}
  var boxElement = document.getElementById()
  
  var options = {
    root: null,
    rootMargin: "0px",
    threshold: 0.01
  };

  observer = new IntersectionObserver(handleFunc, options);
  observer.observe(boxElement);
```

### 基于IntersectionObserver的懒加载的库

于是自己尝试封装了一个基于IntersectionObserver的懒加载的库。

html

```
<img class="J_lazy-load" data-imgsrc="burger.png">
```

你也许注意到上面的代码中，图片文件没有 src 属性么。这是因为它使用了称为 data-imgsrc 的 data 属性来指向图片源。我们将使用这来加载图片

js

```
function lazyLoad(domArr) {
	if ('IntersectionObserver' in window) {
		
		let createObserver = (dom) => {
			var fn = (arr) => {
				let target = arr[0].target
				if (arr[0].isIntersecting) {
					let imgsrc = target.dataset.imgsrc
					if (imgsrc) {
						target.setAttribute('src', imgsrc)
					}
					
					// 解除绑定观察
					observer.unobserve(dom)
				}
			}
			
			var config = {
				root: null,
				rootMargin: '10px',
				threshold: 0.01
			}
			
			var observer =  new IntersectionObserver(fn, config)
			observer.observe(dom)
		}
		
		Array.prototype.slice(domArr)
		domArr.forEach(dom => {
			createObserver(dom)
		})
	}
}

```

这个库的使用也非常简单：

```
// 先引入
import {lazyLoad} from '../util/lazyload.js'

// 进行懒加载
let domArr = document.querySelectorAll('.J_lazy-load')
lazyLoad(domArr)
```

然后测试一下，发现可以正常使用：

![](http://h0.hucdn.com/open/201825/9e5dfa5954ac4545_1604x1300.gif)



### 比较性能

传统的懒加载 lazy-loder 的页面性能如下：

![](http://p8cyzbt5x.bkt.clouddn.com/UC20180620_162431.png)

在12秒内，存在红颜色的掉帧现象，一些地方的帧率偏低（在devtool里面是fps的绿色小山较高的地方），用于 ` scripting ` 阶段的总共有600多ms.

使用intersetctionObserver之后的懒加载性能如下：
![](http://p8cyzbt5x.bkt.clouddn.com/UC20180620_161051.png)
在12秒内，帧率比较平稳，用于 ` scripting ` 阶段的时间只有60多ms了。

优化前的视频：
<iframe
    height=450
    width=800
    src="./assets/1.mp4"
    frameborder=0
    allowfullscreen>
</iframe>

优化之后的视频：

<iframe
    height=450
    width=800
    src="./assets/2.mp4"
    frameborder=0
    allowfullscreen>
</iframe>





参考链接：

1. https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/
2. https://codeburst.io/how-browsers-work-6350a4234634
3. https://developer.mozilla.org/en-US/docs/Archive/Mozilla/Firefox/Style_System_Overview#Style_data_cached_in_style_context_tree
4. https://www.chromium.org/developers/the-rendering-critical-path#TOC-Browser-Thread-Architecture
5. https://www.w3.org/TR/CSS22/visuren.html
6. [css性能优化](https://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles/)
7. [render tree](https://mediaspace.msu.edu/media/How+WebKit+Renders+the+Web++Levi+Weintraub/1_p1nvwd0k)

